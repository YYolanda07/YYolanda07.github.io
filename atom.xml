<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tan&#39;s Blog</title>
  
  <subtitle>Tan&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-24T13:14:35.588Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSAPP虚存的使用和管理</title>
    <link href="http://yoursite.com/2019/05/24/CSAPP%E8%99%9A%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/05/24/CSAPP虚存的使用和管理/</id>
    <published>2019-05-24T12:31:02.000Z</published>
    <updated>2019-05-24T13:14:35.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="物理寻址和虚拟寻址"><a href="#物理寻址和虚拟寻址" class="headerlink" title="物理寻址和虚拟寻址"></a>物理寻址和虚拟寻址</h2><p>使用虚拟寻址时，CPU通过生成一个虚拟地址来访问主存，这个虚拟地址在被送到存储器之前先转换成适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做地址翻译。地址翻译需要CPU硬件和操作系统之间的紧密合作。CPU芯片上叫做存储器管理单元的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容是由操作系统管理的。</p><h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p>一个地址空间的大小是由表示最大地址所需要的位数来描述的。一个包含N=2^n个地址的虚拟地址空间就叫做一个n位地址空间。现代操作系统典型的支持32位或者64为虚拟地址空间。一个系统还有一个物理地址空间，它与系统中物理存储器的M个字节相对应。</p><h2 id="虚拟内存的作用"><a href="#虚拟内存的作用" class="headerlink" title="虚拟内存的作用"></a>虚拟内存的作用</h2><p>使用虚拟内存有许多的好处，操作系统其实为每个进程提供了一个独立的页表，使用不同的页表也就创建了独立的虚拟地址空间。使用虚拟内存可以简化链接、简化加载、简化共享、简化存储器分配、简化保护。</p><h2 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h2><h3 id="命中的地址翻译过程"><a href="#命中的地址翻译过程" class="headerlink" title="命中的地址翻译过程"></a>命中的地址翻译过程</h3><p>1.处理器生成虚拟地址 VA，传给 MMU；<br>2.MMU 生成 PTE 地址，通过高速缓存或主存请求得到它；<br>3.高速缓存或主存返回PTE；<br>4.MMU 构造物理地址，并传送给高速缓存或主存；<br>5.高速缓存或主存返回请求的数据字给处理器。</p><h3 id="不命中的地址翻译过程"><a href="#不命中的地址翻译过程" class="headerlink" title="不命中的地址翻译过程"></a>不命中的地址翻译过程</h3><p>1.处理器生成虚拟地址 VA，传给 MMU；<br>2.MMU 生成 PTE 地址，通过高速缓存或主存请求得到它；<br>3.高速缓存或主存返回PTE；<br>4.PTE 有效位为 0，传递 CPU 的控制，让操作系统内核执行缺页异常处理程序<br>5.确定物理内存的牺牲页，如果该牺牲页已被修改则换出磁盘；<br>6.缺页处理程序页面调入新的页面，并更新内存中的 PTE。<br>7.返回到原来的进程，再次执行缺页指令，此时会命中，MMU 将返回请求的数据字给处理器。</p><h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>内存映射是指将磁盘上的一个文件与虚拟存储器中的一个区域关联起来的这个过程。</p><h3 id="共享对象"><a href="#共享对象" class="headerlink" title="共享对象"></a>共享对象</h3><p>一个对象被映射到虚拟存储器的一个区域，这个区域要么是共享对象，要么是私有对象。如果一个进程A将一个共享对象映射X到了它的虚拟存储器中，那么对于同时也映射了这个共享对象X的其他进程而言，进程A对共享对象X的任何读写操作都是可见的。对于一个映射到私有对象的区域做的改变，对于其他进程来说是不可见的，并且进程对这个区域所做的任何写操作都不会反映在磁盘上的对象中。<br>每个对象都有唯一的一个文件名，在进程1的虚拟存储器中已经完成了私有对象到存储器的映射，进程2如果要映射这个区域只需要将页表条目指向已经映射好的物理存储器位置就行了。如上图所示，进程1和2将一个私有对象映射到了物理存储器的一个区域并共享这个私有对象。这个对象会被标记为只读，当其中一个进程2确实需要写这个区域的时候，就会引发一个保护故障，内核会在物理存储器中创建这个私有对象的一个拷贝，称为写时拷贝，更新页面条目使得进程1指向这个新的条目。然后把老对象修改为可写权限。这样当保护故障程序返回的时候，CPU从新执行写的操作就不会出错了。</p><h3 id="fork函数如何创建独立的虚拟地址空间"><a href="#fork函数如何创建独立的虚拟地址空间" class="headerlink" title="fork函数如何创建独立的虚拟地址空间"></a>fork函数如何创建独立的虚拟地址空间</h3><p>一个进程调用fork函数的时候，内核为新进程创建各种数据结构，并分配PID。为了给新进程创建一个虚拟存储器，它创建的当前进程的mm_struct、区域结构和页表的一个拷贝，内核为两个进程的每个页表标记为只读，并将诶个区域标记为私有的写时拷贝。这样当fork函数返回的时候，新进程的虚拟存储器和当前进程的虚拟存储器刚好相同。任何一个进程进行写操作的时候，才会创建新的页面。</p><h3 id="execve函数实际上如何加载和执行程序"><a href="#execve函数实际上如何加载和执行程序" class="headerlink" title="execve函数实际上如何加载和执行程序"></a>execve函数实际上如何加载和执行程序</h3><p>1.删除已存在的用户区域；<br>2.映射私有区域<br>3.映射共享区域；<br>4.设置程序计数器。</p><h3 id="使用mmap函数创建新的存储器映射"><a href="#使用mmap函数创建新的存储器映射" class="headerlink" title="使用mmap函数创建新的存储器映射"></a>使用mmap函数创建新的存储器映射</h3><p>mmap函数要求内核创建一个新的虚拟内存区域，从地址start开始处创建，并将文件描述符fd指定的对象的一个连续的片映射到这个新的区域。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;物理寻址和虚拟寻址&quot;&gt;&lt;a href=&quot;#物理寻址和虚拟寻址&quot; class=&quot;headerlink&quot; title=&quot;物理寻址和虚拟寻址&quot;&gt;&lt;/a&gt;物理寻址和虚拟寻址&lt;/h2&gt;&lt;p&gt;使用虚拟寻址时，CPU通过生成一个虚拟地址来访问主存，这个虚拟地址在被送到存储器之前
      
    
    </summary>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Y86-64的流水线实现</title>
    <link href="http://yoursite.com/2019/05/22/CSAPP-Y86-64%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/05/22/CSAPP-Y86-64的流水线实现/</id>
    <published>2019-05-22T09:38:02.000Z</published>
    <updated>2019-05-22T11:34:21.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流水线的概述"><a href="#流水线的概述" class="headerlink" title="流水线的概述"></a>流水线的概述</h2><p>简单来说流水线这个概念出现在我们日常生活中，比如餐厅的服务线和自动汽车清洗线都是应用于这个原理。流水线化的一个重要特性就是提高了系统的吞吐量，不过它也会轻微地增加延迟。</p><h2 id="流水线的局限性"><a href="#流水线的局限性" class="headerlink" title="流水线的局限性"></a>流水线的局限性</h2><p>1、不一致的划分<br>之前的是一个理想的流水线化的系统，每个阶段需要的时间都相同。而实际系统通过各阶段的延迟一般是不同的。且运行时钟的速率是由最慢阶段的延迟限制的。<br>2、流水线过深，收益反而下降<br>例如，我们把计算分成6个阶段，每个阶段需要50ps。在每对阶段之间插入流水线寄存器就得到了一个六阶段流水线。这个系统的最小时钟周期为50+20=70ps，吞吐量为14.29GIPS。性能比3阶段流水提高了14.29/8.33=1.71倍。由于通过流水线寄存器的延迟，吞吐量并没有加倍。这个延迟成了流水线吞吐量的一个制约因素。为了提高时钟频率，现代处理器采用了很深的流水线。</p><h2 id="流水线冒险"><a href="#流水线冒险" class="headerlink" title="流水线冒险"></a>流水线冒险</h2><p>使用流水线技术，当相邻指令间存在相关时会导致出现问题。这些相关有：<br>1、数据相关：下一条指令会用到这一条指令计算出的结果<br>2、控制相关：一条指令要确定下一条指令的位置，例如在执行跳转、调用或返回指令时。<br>这些相关可能会导致流水线产生计算错误，称为冒险。</p><h3 id="用暂停来避免数据冒险"><a href="#用暂停来避免数据冒险" class="headerlink" title="用暂停来避免数据冒险"></a>用暂停来避免数据冒险</h3><p>暂停是避免冒险的一种常用技术。让一条指令停顿在译码阶段，直到产生它的源操作数的指令通过了写回阶段，这样我们的处理器就能避免数据冒险。<br>暂停技术就是让一组指令阻塞在它们所处的阶段，而允许其他指令继续通过流水线。</p><h3 id="用转发来避免数据冒险"><a href="#用转发来避免数据冒险" class="headerlink" title="用转发来避免数据冒险"></a>用转发来避免数据冒险</h3><p>在译码阶段从寄存器文件中读入源操作数，但是对这些源寄存器的写有可能要在写回阶段才能进行。与其暂停直到写完成，不如简单地将要写的值传到流水线寄存器E作为源操作数。<br>（即，我们不必等到irmovl $10, %edx和irmovl $3, %eax 完成对寄存器的写更新之后再继续addl，而是在addl译码阶段发现需要%edx、%eax值，译码逻辑不从寄存器文件中去读，而是用前面阶段未写入寄存器的值。）这种将结果直接从一个流水线阶段传到较早阶段的技术称为数据转发。在周期4中，译码阶段逻辑发现有在访存阶段中对寄存器%edx未进行的写，还发现在执行阶段中正在计算寄存器%eax的新值。它用这些值，而不是从寄存器文件中读出的值，作为valA和valB的值。</p><h3 id="加载-使用数据冒险"><a href="#加载-使用数据冒险" class="headerlink" title="加载/使用数据冒险"></a>加载/使用数据冒险</h3><p>有一类数据冒险不能单纯用转发来解决，因为存储器读(访存阶段)在流水线发生的比较晚。<br>我们可以将暂停和转发结合起来，避免加载/使用数据冒险。（既然是来不及发送给后面的指令，那就让后面的指令暂停几个周期，再发送）<br>当mrmovl指令通过执行阶段时，流水线控制逻辑发现译码阶段中的指令(addl)需要从存储器中读出的结果。它会将译码阶段中的addl指令暂停一个周期，导致执行阶段中插入一个气泡。 mrmovl指令从存储器中读出的值可以从访存阶段转发到译码阶段中的addl指令。<br>这种用暂停来处理加载/使用冒险的方法称为加载互锁。加载互锁和转发技术结合起来足以处理所有可能类型的数据冒险。</p><h3 id="避免控制冒险"><a href="#避免控制冒险" class="headerlink" title="避免控制冒险"></a>避免控制冒险</h3><p>在处理器无法根据处于取址阶段的当前指令来确定下一条指令的地址时，就会出现控制冒险，一般来说控制冒险只会出现在ret和跳转指令上。当出现特殊情况时，通过暂停和往流水线中插入气泡的技术可以动态调整流水线的流程。</p><h2 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h2><p>流水线化设计的目的就是每个时钟周期都发射一条新指令，要做到这一点，我们必须在取出当前指令之后，马上确定下一条指令的位置。<br>但如果取出的指令是条件分支指令，要到几个周期后，也就是指令通过执行阶段之后，我们才能知道是否要选择分支。类似的，如果取出的指令是ret，要到指令通过访存阶段，才能确定返回地址。<br>对条件转移来说，我们既可以预测选择了分支，那么新PC值应为valC，也可以预测没有选择分支，那么新PC值应为valP。<br>对ret指令，可能的返回值几乎是无限的，因为返回地址位于栈顶的字，其内容可以是任意的。在设计中，我们不会试图对返回地址做任何预测。只是简单地暂停处理新指令，直到ret指令通过写回阶段。<br>无论哪种情况，我们都必须以某种方式来处理预测错误的情况，因为此时已经取出并部分执行了错误的指令。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>异常可以由程序执行从内部产生，也可以由某个外部信号从外部产生。简单的三种内部异常：<br>1、halt指令<br>2、非法指令<br>3、访问非法地址<br>在简化的ISA模型中，当处理器遇到异常时，会停止，设置适当的状态码，且应该是到异常指令之前的所有指令都已经完成，而其后的指令都不应该对程序员可见的状态产生任何影响。在一个更完整的设计中，处理器会继续调用异常处理程序，这是操作系统的一部分。<br>一般地，通过在流水线结构中加入异常处理逻辑，我们会在每个流水线寄存器中包括一个状态码Stat。如果一条指令在其处理器中于某个阶段产生了一个异常，这个状态字段就被设置成指示异常的种类。<br>异常状态和该指令的其他信息一起沿着流水线传播，直到它到达写回阶段。在此，流水线控制逻辑发现了异常，并停止执行。<br>异常事件不会对流水线中的指令流有任何影响，除了会禁止流水线中后面的指令更新程序员的可见状态，直到异常指令到达最后的流水线阶段。<br>因为指令到达写回阶段的顺序与它们在非流水化的处理器中执行的顺序相同，所以我们可以保证第一条遇到异常的指令会第一个到达写回阶段，此时程序执行会停止，流水线寄存器中的状态码会被记录为程序状态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;流水线的概述&quot;&gt;&lt;a href=&quot;#流水线的概述&quot; class=&quot;headerlink&quot; title=&quot;流水线的概述&quot;&gt;&lt;/a&gt;流水线的概述&lt;/h2&gt;&lt;p&gt;简单来说流水线这个概念出现在我们日常生活中，比如餐厅的服务线和自动汽车清洗线都是应用于这个原理。流水线化的一
      
    
    </summary>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Y86-64顺序的实现</title>
    <link href="http://yoursite.com/2019/05/20/CSAPP-Y86-64%E9%A1%BA%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/05/20/CSAPP-Y86-64顺序的实现/</id>
    <published>2019-05-20T12:48:06.000Z</published>
    <updated>2019-05-22T11:07:16.858Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Y86-64的顺序实现"><a href="#Y86-64的顺序实现" class="headerlink" title="Y86-64的顺序实现"></a>Y86-64的顺序实现</h2><h3 id="跟踪irmovq指令的执行"><a href="#跟踪irmovq指令的执行" class="headerlink" title="跟踪irmovq指令的执行"></a>跟踪irmovq指令的执行</h3><p>一条指令的执行过程通常可以分为取指-&gt;译码-&gt;执行-&gt;访存-&gt;写回-&gt;更新PC，下面以irmovq指令为例，详细的解释这条指令的执行过程。</p><table><thead><tr><th style="text-align:left">阶段</th><th style="text-align:left">通用</th><th style="text-align:left">具体</th></tr></thead><tbody><tr><td style="text-align:left"></td><td style="text-align:left">irmovq V,rB</td><td style="text-align:left">irmovq $128,%rsp</td></tr><tr><td style="text-align:left">取指</td><td style="text-align:left">icode:ifun&lt;-M1[PC]<br>rA:rB&lt;-M1[PC+1]<br>valC&lt;-M8[PC+2]<br>valP&lt;-PC+10</td><td style="text-align:left">M1[0x016]=3:0<br>M1[0x015]=f:4<br>valC&lt;-M1[0x018]=128<br>valP&lt;-0x020</td></tr><tr><td style="text-align:left">译码</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">执行</td><td style="text-align:left">valE&lt;-0+valC</td><td style="text-align:left">valE&lt;-128</td></tr><tr><td style="text-align:left">访存</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">写回</td><td style="text-align:left">R[rB]&lt;-valE</td><td style="text-align:left">R[rB]&lt;-128</td></tr><tr><td style="text-align:left">更新PC</td><td style="text-align:left">PC&lt;-valP</td><td style="text-align:left">PC&lt;-0x20</td></tr></tbody></table><p>其余的还有其他指令，比如ret、popq、rmmovq，它们的执行过程其实也都是遵循通用规则的。</p><h3 id="SEQ的时序"><a href="#SEQ的时序" class="headerlink" title="SEQ的时序"></a>SEQ的时序</h3><p>要控制处理器中活动的时序，只需要寄存器和内存的时钟控制。通过时钟周期来控制元素的更新，通过组合逻辑来传播，每次时钟周期由低到高时，处理器开始执行一条新指令。处理器从来不需要为了完成一条指令的执行而去读该指令更新了的状态。</p><h3 id="SEQ阶段的实现"><a href="#SEQ阶段的实现" class="headerlink" title="SEQ阶段的实现"></a>SEQ阶段的实现</h3><p>一条指令在顺序的处理器中执行一般来说需要五个阶段，需要根据不同的指令取出其所需要的数据，可以使用HCL来描述这个过程。SEQ执行只有当上一个阶段执行完才会执行下一个阶段，这样就会导致运行的很慢，而且不能充分利用硬件单元，在接下来会学习流水线化的运行原理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Y86-64的顺序实现&quot;&gt;&lt;a href=&quot;#Y86-64的顺序实现&quot; class=&quot;headerlink&quot; title=&quot;Y86-64的顺序实现&quot;&gt;&lt;/a&gt;Y86-64的顺序实现&lt;/h2&gt;&lt;h3 id=&quot;跟踪irmovq指令的执行&quot;&gt;&lt;a href=&quot;#跟踪ir
      
    
    </summary>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP逻辑设计</title>
    <link href="http://yoursite.com/2019/05/18/CSAPP%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2019/05/18/CSAPP逻辑设计/</id>
    <published>2019-05-18T10:30:54.000Z</published>
    <updated>2019-05-22T11:36:13.706Z</updated>
    
    <content type="html"><![CDATA[<h2 id="逻辑设计与HCL"><a href="#逻辑设计与HCL" class="headerlink" title="逻辑设计与HCL"></a>逻辑设计与HCL</h2><p>这部分内容应该是之前上过的一门课-数字电路设计与分析的精简版了吧，主要是讲各种逻辑电路的设计。</p><h3 id="逻辑门"><a href="#逻辑门" class="headerlink" title="逻辑门"></a>逻辑门</h3><p>基本的逻辑门类型有：AND、OR、NOT<br>逻辑门是活动的，输入变化输出就会变化。</p><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p><strong>1.单个位</strong><br>eq = (a &amp;&amp; b) || (!a &amp;&amp; !b) 这个表达式的结果分析，只有a 和 b 都为 0 或者都为 1 的时候，输出才为1。<br>(a &amp;&amp; s) || (b &amp;&amp; !s) 我们分析如果s为1，则结果为a，否则结果为b。<br><strong>2.多个位</strong><br>eq=(A==B) 这里A和B都是int型的，表达式是在判断64位字A和B中的每一位是否相同。</p><h3 id="HCL表达式-和-C-语言逻辑表达式的区别"><a href="#HCL表达式-和-C-语言逻辑表达式的区别" class="headerlink" title="HCL表达式 和 C 语言逻辑表达式的区别"></a>HCL表达式 和 C 语言逻辑表达式的区别</h3><p>1.逻辑门是持续输出的，如果电路的输入变化了，在一定的延迟之后，输出也会相应的变化，而C表达式是在执行到的时候才会求值。<br>2.两者操作的值不同，逻辑门只对值 0 和值 1 进行操作，而C 逻辑表达式允许参数是任意整数，0表示false，其它任意值都表示true。<br>3.逻辑表达式存在短路，比如对于a &amp;&amp; b这个符号来说，C语言中的规定是如果前者为假，则后者不会再计算。而HCL当中没有这种说法。</p><h3 id="存储器和时钟"><a href="#存储器和时钟" class="headerlink" title="存储器和时钟"></a>存储器和时钟</h3><p>组合电路是一直持续输出的，因此它无法保持一个状态不变。也就是说组合电路从本质上来讲，不存储任何信息。他们只是简单的响应输入信号，产生等于输入的某个函数的输出。但我们的计算机是需要存储数据的，因此就需要能保存状态的存储设备。存储设备是由一个时钟控制，时钟是一个周期型号，它控制着存储设备什么时候更新设备里的值。<br>常用的存储设备一般有两种：<br>时钟寄存器：简称寄存器，存储单个位或字。时钟信号控制寄存器加载输入值。<br>随机访问存储器：简称存储器，存储多个字，用地址来选择该读或者该写哪个字。</p><h2 id="Y86-64的顺序实现"><a href="#Y86-64的顺序实现" class="headerlink" title="Y86-64的顺序实现"></a>Y86-64的顺序实现</h2><p>处理一条指令包含很多操作，将它们组织成某个特殊的阶段序列。分为以下几个阶段：<br>取指：取指阶段从存储器读取指令字节，地址为程序计数器（PC）的值<br>译码：译码阶段从寄存器文件读入最多两个操作数,得到val A 和 / 或 val B<br>执行：执行阶段，算术/逻辑单元要么执行指令明确的操作（根据ifun的值），计算存储器引用的有效地址，要么增加或减少栈指针。得到的值为valE<br>访存：访存阶段可将数据写入存储器或从存储器读出数据<br>写回：最多可写两个结果到寄存器文件<br>更新PC：将PC设置成下一指令的地址</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;逻辑设计与HCL&quot;&gt;&lt;a href=&quot;#逻辑设计与HCL&quot; class=&quot;headerlink&quot; title=&quot;逻辑设计与HCL&quot;&gt;&lt;/a&gt;逻辑设计与HCL&lt;/h2&gt;&lt;p&gt;这部分内容应该是之前上过的一门课-数字电路设计与分析的精简版了吧，主要是讲各种逻辑电路的设计
      
    
    </summary>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP浮点数操作</title>
    <link href="http://yoursite.com/2019/05/17/CSAPP%E6%B5%AE%E7%82%B9%E6%95%B0%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/05/17/CSAPP浮点数操作/</id>
    <published>2019-05-17T09:26:07.000Z</published>
    <updated>2019-05-22T11:37:34.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浮点代码"><a href="#浮点代码" class="headerlink" title="浮点代码"></a>浮点代码</h2><p>处理器的浮点体系结构包括多个方面，会影响对浮点数据操作的程序如何被映射到机器上，包括：<br>1） 如何存储和访问浮点数据。通常是通过某种寄存器方式来完成。<br>2） 对浮点数据操作的指令。<br>3） 想函数传递浮点数参数和从函数返回浮点数结构的规则。<br>4） 函数调用过程保持寄存器的规则——例如，一些寄存器被指定为调用者保存，而其他的被指定为被调用者保存。<br>AVX浮点体系结构允许数据存储在16个YMM寄存器中，它们的名字为%ymm0~%ymm15。每个YMM寄存器都是256位（32位）。</p><h3 id="浮点传送和转换操作"><a href="#浮点传送和转换操作" class="headerlink" title="浮点传送和转换操作"></a>浮点传送和转换操作</h3><p>浮点传送和转换操作指令汇总</p><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">源1</th><th style="text-align:center">源2</th><th style="text-align:center">目的</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">vmovss</td><td style="text-align:center">M32</td><td style="text-align:center">NULL</td><td style="text-align:center">X</td><td style="text-align:center">传送单精度数</td></tr><tr><td style="text-align:center">vmovss</td><td style="text-align:center">X</td><td style="text-align:center">NULL</td><td style="text-align:center">M32</td><td style="text-align:center">传送单精度数</td></tr><tr><td style="text-align:center">vmovsd</td><td style="text-align:center">M64</td><td style="text-align:center">NULL</td><td style="text-align:center">X</td><td style="text-align:center">传送双精度数</td></tr><tr><td style="text-align:center">vmovsd</td><td style="text-align:center">X</td><td style="text-align:center">NULL</td><td style="text-align:center">M64</td><td style="text-align:center">传送双精度数</td></tr><tr><td style="text-align:center">vmovaps</td><td style="text-align:center">X</td><td style="text-align:center">NULL</td><td style="text-align:center">X</td><td style="text-align:center">传送对齐的封装好的单精度数</td></tr><tr><td style="text-align:center">vmovapd</td><td style="text-align:center">X</td><td style="text-align:center">NULL</td><td style="text-align:center">X</td><td style="text-align:center">传送对齐的封装好的双精度数</td></tr><tr><td style="text-align:center">vcvttss2si</td><td style="text-align:center">X/M32</td><td style="text-align:center">NULL</td><td style="text-align:center">R32</td><td style="text-align:center">用截断的方法把单精度数转换成整数</td></tr><tr><td style="text-align:center">vcvttsd2si</td><td style="text-align:center">X/M64</td><td style="text-align:center">NULL</td><td style="text-align:center">R32</td><td style="text-align:center">用截断的方法把双精度数转换成整数</td></tr><tr><td style="text-align:center">vcvttss2siq</td><td style="text-align:center">X/M32</td><td style="text-align:center">NULL</td><td style="text-align:center">R64</td><td style="text-align:center">用截断的方法把单精度数转换成四字整数</td></tr><tr><td style="text-align:center">vcvttsd2siq</td><td style="text-align:center">X/M64</td><td style="text-align:center">NULL</td><td style="text-align:center">R64</td><td style="text-align:center">用截断的方法把双精度数转换成四字整数</td></tr><tr><td style="text-align:center">vcvtsi2ss</td><td style="text-align:center">M32/R32</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">把整数转换成单精度数</td></tr><tr><td style="text-align:center">vcvtsi2sd</td><td style="text-align:center">M32/R32</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">把整数转换成双精度数</td></tr><tr><td style="text-align:center">vcvtsi2ssq</td><td style="text-align:center">M64/R64</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">把四字整数转换成单精度数</td></tr><tr><td style="text-align:center">vcvtsi2sdq</td><td style="text-align:center">M64/R64</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">把四字整数转换成双精度数</td></tr><tr><td style="text-align:center">vcvtps2pd</td><td style="text-align:center">X1</td><td style="text-align:center">NULL</td><td style="text-align:center">X2</td><td style="text-align:center">**把X1中两个低位单精度值扩展成X2中的两个双精度值</td></tr><tr><td style="text-align:center">vunpcklps</td><td style="text-align:center">X1</td><td style="text-align:center">X2</td><td style="text-align:center">X3</td><td style="text-align:center">交叉放置X1和X2的值存储到X3中</td></tr></tbody></table><h3 id="过程中的浮点代码"><a href="#过程中的浮点代码" class="headerlink" title="过程中的浮点代码"></a>过程中的浮点代码</h3><p>在x86-64中，XMM寄存器用来向函数传递浮点参数，以及从函数返回浮点值。<br>1） XMM寄存器%xmm0~%xmm7最多可以传递8个浮点参数（额外的可以通过栈传递）。<br>2） 函数使用寄存器xmm0来返回浮点值。<br>3） 所有的XMM寄存器都是调用者保存的。被调用者可以不用保存就覆盖这些寄存器中任一个。 </p><h3 id="浮点运算操作"><a href="#浮点运算操作" class="headerlink" title="浮点运算操作"></a>浮点运算操作</h3><p>浮点的运算符和整数的运算符大同小异，需要注意的是AVX浮点操作不能以立即数值作为操作数。</p><h2 id="Y86指令集体系结构"><a href="#Y86指令集体系结构" class="headerlink" title="Y86指令集体系结构"></a>Y86指令集体系结构</h2><h3 id="Y86指令"><a href="#Y86指令" class="headerlink" title="Y86指令"></a>Y86指令</h3><p>首先我们要知道的是Y86指令是不存在的，这是本书的作者受到 IA32指令，也就是“x86”的启发，所假想出来的一种处理器体系结构，与 “x86” 相比，Y86指令集的数据类型、指令和寻址方式都要少一些，字节级编码也比较简单。但是它仍然足够完整，能够写一些简单的处理证书的程序，而设计一个Y86处理器要求我们面对许多处理器设计者同样面临的问题。所以学习Y86处理器的设计是很有必要的。<br>定义一个指令集体系结构，会包括定义各种状态元素，指令集和它们的编码、一组编程规范和异常处理事件。</p><h3 id="指令编码"><a href="#指令编码" class="headerlink" title="指令编码"></a>指令编码</h3><p>Y86每条指令的第一个字节有唯一的代码和功能组合，给定这个字节，我们就可以决定所有其他附加字节的长度和含义。这个性质保证了处理器可以无二义性的执行目标程序代码。即使代码嵌入在程序的其它字节中，只要从序列的第一个字节开始处理，我们仍然可以很容易的确定指令序列。反过来，如果不知道一段代码序列的起始位置，我们就不能准确的确定怎样将序列划分为单独的指令。对于试图直接从目标代码字节序列中抽取出机器级程序的反汇编程序和其它一些工具来说，就带来了困难。</p><h3 id="关于RISC和CISC"><a href="#关于RISC和CISC" class="headerlink" title="关于RISC和CISC"></a>关于RISC和CISC</h3><p>两种不同的指令集，各有利弊，这个在之前的博客中也做过对比，想说明的一点是，人们应该考虑如何把两种指令集做结合，才能把处理器作用发挥的更好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;浮点代码&quot;&gt;&lt;a href=&quot;#浮点代码&quot; class=&quot;headerlink&quot; title=&quot;浮点代码&quot;&gt;&lt;/a&gt;浮点代码&lt;/h2&gt;&lt;p&gt;处理器的浮点体系结构包括多个方面，会影响对浮点数据操作的程序如何被映射到机器上，包括：&lt;br&gt;1） 如何存储和访问浮点数据。
      
    
    </summary>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP数据结构</title>
    <link href="http://yoursite.com/2019/05/15/CSAPP%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2019/05/15/CSAPP数据结构/</id>
    <published>2019-05-15T08:37:54.000Z</published>
    <updated>2019-05-22T11:38:47.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机系统学习"><a href="#计算机系统学习" class="headerlink" title="计算机系统学习"></a>计算机系统学习</h2><h3 id="数组分配和访问"><a href="#数组分配和访问" class="headerlink" title="数组分配和访问"></a>数组分配和访问</h3><h4 id="数组的基本原则"><a href="#数组的基本原则" class="headerlink" title="数组的基本原则"></a>数组的基本原则</h4><p>数组是某种基本数据类型数据的集合，对于数据类型 T 和整型常数 N，数组的声明如下：</p><pre><code>T  A[N]</code></pre><p>上面的 A 称为数组名称。它有两个效果：<br>1.它在存储器中分配一个 L*N 字节的连续区域，这里 L 是数据类型 T 的大小（单位为字节）<br>2.A作为指向数组开头的指针，如果分配的连续区域的起始地址为xa，那么这个指针的值就是xa</p><h4 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h4><p>C语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩。也就是说，如果 P 是一个执行类型 T 的数据的指针，P 的值为 xp,那么表达式P+i 的值为 xp+L*i，这里 L 是数据类型T的大小。</p><h4 id="数组嵌套"><a href="#数组嵌套" class="headerlink" title="数组嵌套"></a>数组嵌套</h4><p>也就是数组的数组，比如二维数组 int A[5][3]。这个时候上面所讲的数组的分配和引用也是成立的。&amp;A[2][0]=xa+24</p><h4 id="定长数组和变长数组"><a href="#定长数组和变长数组" class="headerlink" title="定长数组和变长数组"></a>定长数组和变长数组</h4><p>如果在编译时数组的长度确定，我们就称为定长数组，反之则称为变长数组。<br>比如int A[10]，就是一个定长数组，它的长度为10，它的长度在编译时已经确定了，因为长度是一个常量。之前的C编译器不允许在声明数组时，将长度定义为一个变量，而只能是常量，不过当前的C/C++编译器已经开始支持动态数组，但是C++的编译器依然不支持方法参数。另外，C语言还提供了类似malloc和calloc这样的函数动态的分配内存空间，我们可以将返回结果强转为想要的数组类型。</p><h3 id="异质的数据结构"><a href="#异质的数据结构" class="headerlink" title="异质的数据结构"></a>异质的数据结构</h3><p>异质结构是指不同数据类型的数组组合，比如C语言当中的结构（struct）与联合（union）。在理解数组的基础上，这两种数据结构都非常好理解。</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>考虑一个结构的声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">    char c;</span><br><span class="line">&#125; A;</span><br></pre></td></tr></table></figure></p><p>这是一个非常简单的结构体，总共有12个字节，为什么是12个字节呢？这是因为数据对齐的原因。为了提高数据读取的速度，一般情况下会将数据以2的指数倍对齐，具体是2、4、8还是16，得根据具体的硬件设施以及操作系统来决定。<br>这样做的好处是，处理器可以统一的一次性读取4（也可能是其它数值）个字节，而不再需要针对特殊的数据类型读取做特殊处理。在这个例子来说，也就是说在读取a、b、c时，都可以统一的读取4个字节。特殊的，这里0-3的位置用于存储a，4-7的位置用于存储b，8的位置用于存储c，而9-11则用于填充，其中都是空的。</p><h4 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h4><p>与结构体不同的是，联合会复用内存空间，以节省内存，考虑一个联合的声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">union &#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">    char c;</span><br><span class="line">&#125; B;</span><br></pre></td></tr></table></figure></p><p>这次总共会占4个字节，这是因为a、b、c会共用4个字节，这样做的目的是为了节省内存空间，显然它比结构体节省了8个字节的空间。它与结构体最大的区别就在于，对a、b、c赋值时，联合会覆盖掉之前的赋值，而结构体则不会，结构体可以同时保存a、b、c的值。</p><h3 id="在机器级程序中将控制与数据结合起来"><a href="#在机器级程序中将控制与数据结合起来" class="headerlink" title="在机器级程序中将控制与数据结合起来"></a>在机器级程序中将控制与数据结合起来</h3><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>指针以一种统一方式，对不同数据结构中的元素产生引用。 </p><h4 id="GDB调试器的使用"><a href="#GDB调试器的使用" class="headerlink" title="GDB调试器的使用"></a>GDB调试器的使用</h4><p>GDB调试器是一种非常实用的辅助工具，可以更好地帮助我们通过阅读代码来推断程序的行为。具体的命令可以参考书上的表格。</p><h4 id="内存越界引用和缓冲区溢出"><a href="#内存越界引用和缓冲区溢出" class="headerlink" title="内存越界引用和缓冲区溢出"></a>内存越界引用和缓冲区溢出</h4><p>在栈中分配某个字符数组来保存字符串，但是字符串的长度超出了为数组分配的空间，这样就会引起缓冲器溢出。<br>缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。这是一种最常见的通过计算机网络攻击系统安全的方法。</p><h4 id="对抗缓冲区溢出攻击"><a href="#对抗缓冲区溢出攻击" class="headerlink" title="对抗缓冲区溢出攻击"></a>对抗缓冲区溢出攻击</h4><p><strong>1.栈随机化</strong><br>为了在系统中插入攻击代码，攻击者既要插入代码，也要插入指向这段代码的指针，这个指针也是攻击字符串的一部分。产生这个指针需要知道这个字符串放置的栈地址。<br>栈随机化的思想使得栈的位置在程序每次运行时都有变化。这类技术称为地址空间布局随机化（Address-Space Layout Randomization)，简称ASLR。<br>通常攻击者使用”空操作雪橇（nop sled）“，使程序”滑过“目标序列，即在实际攻击代码前插入一段很长的nop(读作“no op”，no operation的缩写）指令。<br><strong>2.栈破坏检测</strong><br>计算机的第二道防线是能够检测到何时栈已经被破坏。<br>GCC提供一种栈保护者机制，来检测缓冲区越界。其思想是在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的金丝雀（canary），也称为哨兵值（guard value），是在程序每次运行时随机产生的。<br><strong>3. 限制可执行代码区域</strong><br>最后一招是消除攻击者向系统插入可执行代码的能力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;计算机系统学习&quot;&gt;&lt;a href=&quot;#计算机系统学习&quot; class=&quot;headerlink&quot; title=&quot;计算机系统学习&quot;&gt;&lt;/a&gt;计算机系统学习&lt;/h2&gt;&lt;h3 id=&quot;数组分配和访问&quot;&gt;&lt;a href=&quot;#数组分配和访问&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP过程的实现</title>
    <link href="http://yoursite.com/2019/05/13/CSAPP%E8%BF%87%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/05/13/CSAPP过程的实现/</id>
    <published>2019-05-13T09:45:11.000Z</published>
    <updated>2019-05-22T11:39:48.266Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机系统学习"><a href="#计算机系统学习" class="headerlink" title="计算机系统学习"></a>计算机系统学习</h2><p>今天学习了过程的控制，过程是软件中的一种抽象，可以在程序中的某个地方调用某个过程来实现某种功能。</p><h3 id="栈帧的结构"><a href="#栈帧的结构" class="headerlink" title="栈帧的结构"></a>栈帧的结构</h3><p>栈帧在过程中必不可少，如果我们要想搞清楚过程的实现，就必须先知道栈帧的结构是如何构成的。栈帧其实可以认为是程序栈的一段，而程序栈又是存储器的一段，因此栈帧说到底还是存储器的一段。<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g2zu8mtlm2j30jn0dx3yq.jpg" alt><br>这幅图可以表示栈帧的结构，它由一系列栈帧构成，这些栈帧每一个都对应一个过程，而且每一个帧指针+4的位置都存储着函数的返回地址，每一个帧指针指向的存储器位置当中都备份着调用者的帧指针。</p><h3 id="过程的实现"><a href="#过程的实现" class="headerlink" title="过程的实现"></a>过程的实现</h3><p>总的来说，过程实现当中，参数传递以及局部变量内存的分配和释放都是通过栈帧来实现的，大部分情况下，我们认为过程调用当中做了以下几个操作。<br>1、备份原来的帧指针，调整当前的帧指针到栈指针的位置<br>2、建立起来的栈帧就是为被调用者准备的，当被调用者使用栈帧时，需要给临时变量分配预留内存<br>3、备份被调用者保存的寄存器当中的值，如果有值的话，备份的方式就是压入栈顶。<br>4、使用建立好的栈帧，比如读取和写入，一般使用mov，push以及pop指令等等。<br>5、恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了。因此在恢复时，大多数会使用pop指令，但也并非一定如此。<br>6、释放被调用者的栈帧，释放就意味着将栈指针加大，而具体的做法一般是直接将栈指针指向帧指针。<br>7、恢复调用者的栈帧，恢复其实就是调整栈帧两端，使得当前栈帧的区域又回到了原始的位置。<br>8、弹出返回地址，跳出当前过程，继续执行调用者的代码。此时会将栈顶的返回地址弹出到PC，然后程序将按照弹出的返回地址继续执行。这个过程一般使用ret指令完成。<br>过程的实现大概就是以上八个步骤组成的，不过这些步骤并不都是必须的，有的时候，开启编译器的优化会优化掉很多步骤。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>过程在平时的程序中扮演着很重要的角色，基本上一些功能稍微复杂一点的程序都需要用到过程。过程可以帮助隐藏掉一些很复杂的实现步骤，甚至有一些过程可以直接提供API接口，只需要连接上接口就可以实现该过程的功能，同时这也在开发过程中帮助开发人员省了不少力气。通过本节的学习，我基本了解在汇编语言中，在调用过程时寄存器和程序内存会发生的变化，同时这也更好的帮助我理解寄存器的内部结构情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;计算机系统学习&quot;&gt;&lt;a href=&quot;#计算机系统学习&quot; class=&quot;headerlink&quot; title=&quot;计算机系统学习&quot;&gt;&lt;/a&gt;计算机系统学习&lt;/h2&gt;&lt;p&gt;今天学习了过程的控制，过程是软件中的一种抽象，可以在程序中的某个地方调用某个过程来实现某种功能。&lt;/
      
    
    </summary>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP汇编指令2</title>
    <link href="http://yoursite.com/2019/05/12/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05-12/"/>
    <id>http://yoursite.com/2019/05/12/CSAPP学习笔记5-12/</id>
    <published>2019-05-12T08:45:56.000Z</published>
    <updated>2019-05-19T04:51:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机系统学习"><a href="#计算机系统学习" class="headerlink" title="计算机系统学习"></a>计算机系统学习</h2><h3 id="条件码寄存器"><a href="#条件码寄存器" class="headerlink" title="条件码寄存器"></a>条件码寄存器</h3><p>书中列出了四种常用的寄存器，它们的名字与作用分别如下所述。<br>CF：进位标志寄存器，它记录无符号操作的溢出，当溢出时会被设为1。<br>ZF：零标志寄存器，当计算结果为0时将会被设为1。<br>SF：符号标志寄存器，当计算结果为负数时会被设为1。<br>OF：溢出标志寄存器，当计算结果导致了补码溢出时，会被设为1。<br>从上面寄存器的简单说明可以看出，ZF和SF可以判断结果的符号，而CF和OF可以判断无符号和补码的溢出。而我们平时使用的高级程序语言，就仅仅靠这四个寄存器，就可以演化出千变万化的流程控制。<br>几乎所有的算术与逻辑指令都会改变条件码寄存器的值，不过改变的前提是触发了条件码寄存器的条件。比如对于subl %edx,%eax这个减法指令，假设%edx和%eax寄存器的值都为0x10，则两者相减的结果为0，此时ZF寄存器将会被自动设为1。对于其它的指令运算，都是类似的，会根据结果的不同而设置不同的条件码寄存器。</p><h3 id="访问条件码"><a href="#访问条件码" class="headerlink" title="访问条件码"></a>访问条件码</h3><p>对于普通寄存器来讲，使用的时候一般是直接读取它的值，而对于条件码寄存器来说，则不一定非要读取它的值才能使用。对于条件码寄存器来讲，有三种使用方式，都可以让它发挥作用。<br>1、可以根据条件码寄存器的某个组合，将一个字节设置为0或1，其实这个就相当于读值。<br>2、可以直接条件跳转到程序的某个其它的部分。<br>3、可以有条件的传送数据。<br>这里面第一种方式其实就是普通寄存器的用法，直接读取条件码寄存器的值，然后进行使用。对于第二和第三种来说，就不是这样了，它们不会显示的读取条件码寄存器的值，而是直接使用。<br>本节最难的地方，就在于如何将条件码寄存器的组合与条件联系起来。只要理解了这一点，那么条件码寄存器就算是基本掌握了。对于所有的组合都基于a-b这样的前提，也就是说条件码寄存器的值是经过了一个减运算设置后的值。例如，对于e-&gt;ZF这样的形式，代表的意思是字母e作为后缀时，则以ZF的值为1视为条件成立。</p><table><thead><tr><th style="text-align:center">组合</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">e-&gt;ZF</td><td style="text-align:center">相等</td></tr><tr><td style="text-align:center">ne-&gt;~ZF</td><td style="text-align:center">不相等</td></tr><tr><td style="text-align:center">s-&gt;SF</td><td style="text-align:center">负数</td></tr><tr><td style="text-align:center">ns-&gt;~SF</td><td style="text-align:center">非负数</td></tr><tr><td style="text-align:center">l-&gt;SF^OF</td><td style="text-align:center">有符号的小于</td></tr><tr><td style="text-align:center">le-&gt;(SF^OF)或ZF</td><td style="text-align:center">有符号的小于等于</td></tr><tr><td style="text-align:center">g-&gt;~(SF^OF)&amp;~ZF</td><td style="text-align:center">有符号的大于</td></tr><tr><td style="text-align:center">ge-&gt;~(SF^OF)</td><td style="text-align:center">有符号的大于等于</td></tr><tr><td style="text-align:center">b-&gt;CF</td><td style="text-align:center">无符号的小于</td></tr><tr><td style="text-align:center">be-&gt;CF或ZF</td><td style="text-align:center">无符号的小于等于</td></tr><tr><td style="text-align:center">a-&gt;~CF&amp;~ZF</td><td style="text-align:center">无符号的大于</td></tr><tr><td style="text-align:center">ae-&gt;~CF</td><td style="text-align:center">无符号的大于等于</td></tr></tbody></table><h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><p>这个指令是我们程序实现流程控制的关键指令，它可以直接将程序跳转到指定的位置，又或者根据条件码寄存器的组合进行条件跳转。总的来说，跳转指令的地址编码一般有两种，第一种是基于PC的，第二种则是绝对地址。基于PC（程序计数器）是指给出一个偏移量，这个偏移量基于当前下一条指令的地址，也就是PC当中的值，这是一种最常用的方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3: eb 03         jmp 8 &lt;loop+0x8&gt;</span><br><span class="line">5: 48 d1 f8      sar %rax</span><br><span class="line">8：</span><br><span class="line">b: 7f f8         jg 5 &lt;loop+0x5&gt;</span><br><span class="line">d: f3 c3         repz retq</span><br></pre></td></tr></table></figure></p><p>对于3处字节编码的第二个字节为03，把它加上0x5，就是下一条指令的地址。而对于b处字节编码的第二个字节为f8，补码转换为10进制-8，加上0xd，得到0x5.<br>跳转指令一个最大的应用就是可以实现条件分支，一种是通过条件控制来实现，简单理解是先判断再执行；另一种是通过条件传送来实现，先执行再判断。这两种实现方式各有利弊，要根据实际的应用来判断使用哪一个更好。</p><h3 id="循环指令"><a href="#循环指令" class="headerlink" title="循环指令"></a>循环指令</h3><p>循环指令一般有三种do-while、while和for。<br><strong>do-while</strong><br>这个循环结构是先执行循环体的内容，然后再进行判断条件，成立继续循环，不成立就跳出。在汇编中可以使用cmp+label来模拟这个过程。<br><strong>while</strong><br>这个循环结构是先判断条件是否成立，然后才进入循环体。在汇编中一种是执行一个无条件跳转到循环结尾处，以此来执行初始的测试。另一种是先进行判断，然后就是do-while的过程。<br><strong>for</strong><br>for循环结构其实完全可以沿用while循环的方法，只需要把for的各个条件匹配到while中即可。</p><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>我平时在程序中很少使用到switch分支语句，它适用于那种对变量进行很密集的判断，这个最好的应用大概就是分别指令集了吧。switch语句的实现很简单，可以用多重if-else来理解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    movl    8(%ebp), %eax//取a</span><br><span class="line">    cmpl    $10, %eax//比较a和10</span><br><span class="line">    je    .L10//如果a等于10，跳到.L10进行a=a+10的操作</span><br><span class="line">    cmpl    $20, %eax//比较a和20</span><br><span class="line">    je    .L11//如果a等于20，跳到.L11进行a=a+20的操作</span><br><span class="line">    jmp    .L14//如果a不等于10也不等于20，则跳到.L14进行a=a+30的操作</span><br><span class="line">.L10:</span><br><span class="line">    addl    $10, 8(%ebp)//a=a+10</span><br><span class="line">    jmp    .L12//break</span><br><span class="line">.L11:</span><br><span class="line">    addl    $20, 8(%ebp)//a=a+20</span><br><span class="line">    jmp    .L12//break</span><br><span class="line">.L14:</span><br><span class="line">    addl    $30, 8(%ebp)//a=a+30</span><br><span class="line">.L12:</span><br><span class="line">    movl    12(%ebp), %eax//取b</span><br><span class="line">    movl    8(%ebp), %edx//取a</span><br><span class="line">    leal    (%edx,%eax), %eax//计算a+b并作为返回值</span><br><span class="line">    /* switch语句实现 */</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;计算机系统学习&quot;&gt;&lt;a href=&quot;#计算机系统学习&quot; class=&quot;headerlink&quot; title=&quot;计算机系统学习&quot;&gt;&lt;/a&gt;计算机系统学习&lt;/h2&gt;&lt;h3 id=&quot;条件码寄存器&quot;&gt;&lt;a href=&quot;#条件码寄存器&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP汇编指令1</title>
    <link href="http://yoursite.com/2019/05/10/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05-9-5-10/"/>
    <id>http://yoursite.com/2019/05/10/CSAPP学习笔记5-9-5-10/</id>
    <published>2019-05-10T09:47:38.000Z</published>
    <updated>2019-05-19T04:50:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机系统学习"><a href="#计算机系统学习" class="headerlink" title="计算机系统学习"></a>计算机系统学习</h2><p>开始学习第三章程序的机器级表示，我竟然惊喜地发现这一章的内容正是我想学习但一直没找到汇总很好的学习资源。这两天主要在学习关于汇编指令的基础知识。</p><h3 id="为什么要学习汇编"><a href="#为什么要学习汇编" class="headerlink" title="为什么要学习汇编"></a>为什么要学习汇编</h3><p>有的人说，汇编语言的可读性和可移植性都很差，高级语言很容易理解、兼容性很好。为什么要学汇编语言而不是高级语言？<br>因为想要真正了解计算机系统，了解计算机是如何工作的，想要做一些漏洞分析，汇编语言都是必不可少的。</p><h3 id="生成汇编代码"><a href="#生成汇编代码" class="headerlink" title="生成汇编代码"></a>生成汇编代码</h3><p>一般生成汇编代码有两种途径，一种是从高级语言生成汇编代码，这时可以借助gcc编译器，比如在Linux环境下，使用命令</p><pre><code>&gt; gcc -Og -S xx.c</code></pre><p>就可以看到C语言编译器产生的汇编代码了；而另一种是对可执行程序反汇编生成汇编代码，在Linux上一般使用objdump工具，敲命令行</p><pre><code>&gt; objdump -d xx.o</code></pre><h3 id="汇编指令概述"><a href="#汇编指令概述" class="headerlink" title="汇编指令概述"></a>汇编指令概述</h3><p><strong>汇编代码格式</strong><br>汇编代码格式有两种，分别是是ATT和Intel格式，关于这两种汇编格式，在我之前的博客中做过总结。本书中用到的都是ATT格式的汇编代码。<br><strong>数据格式</strong><br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g2we1z27mxj30hb073t9b.jpg" alt><br><strong>寄存器</strong><br>寄存器是CPU当中非常重要的对象，一般情况下，很多临时变量都会存储在这里.下面是一张书中的寄存器图示，它基于IA32架构给出。<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g2we40o0vzj30do0aodge.jpg" alt><br><strong>操作数指令符</strong><br>不同指令符的表示方式一共有三种，一种是$符号后跟一个标准C表示的整数，比如$100，$0x11等等。第二种则是寄存器，当它作为一个操作数的时候，则是取的寄存器当中的数值。另外，对于寄存器来说，也可以选择性的操作4个、2个、1个字节，而并不一定非要操作4个字节。最后一种，则是我们相对来说最熟悉的，就是存储器或者说内存。当它作为一个操作数的时候，会去计算存储器地址的数值，然后去这个地址取相应的数值。</p><h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p>数据传送指令的目的是为了将一个数据从一个位置复制到另外一个位置。既然如此，那么数据传送指令就会包含一个源操作数和一个目的操作数，指令会将原操作数的值复制到目的操作数并覆盖。<br>数据传送指令一共可分为五种，分别是mov、movs、movz、push以及pop。这几种指令之前也分别做过总结，通过学习本节更系统地了解这些指令，算是复习了一遍吧。</p><h3 id="算术与逻辑运算操作指令"><a href="#算术与逻辑运算操作指令" class="headerlink" title="算术与逻辑运算操作指令"></a>算术与逻辑运算操作指令</h3><p>算术与逻辑运算包括很多种，比如最常见的加减乘除、与或非、左移右移等等。基本的加减乘除，位操作都比较基础了，这里就不再多说。通过本书我还学到了一个很精妙的指令，就是取地址运算符leaq。<br>leaq指令是非常神奇的一个指令，它可以取一个存储器操作数的地址，并且将其赋给目的操作数。如果用C语言当中来对应的话，它就相当于&amp;运算。<br>比如对于leaq 4(%rdx,%rdx,4),%rax这条指令来讲，我们假设%rdx寄存器的值为x的话，那么这条指令的作用就是将 4 + x + 4x = 5x + 4赋给%rax寄存器。它和mov指令的区别就在于，假设是movq 4(%rdx,%rdx,4),%rax这个指令，它的作用是将内存地址为5x+4的内存区域的值赋给%rax寄存器，而leaq指令只是将5x+4这个地址赋给目的操作数%rax而已，它并不对存储器进行引用的值的计算。<br>leaq指令能执行加法和有限形式的乘法，在编译一些比较复杂的算术表达式，使用leaq指令就会变得很简单，能有效减少程序的大小，提高代码执行效率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;计算机系统学习&quot;&gt;&lt;a href=&quot;#计算机系统学习&quot; class=&quot;headerlink&quot; title=&quot;计算机系统学习&quot;&gt;&lt;/a&gt;计算机系统学习&lt;/h2&gt;&lt;p&gt;开始学习第三章程序的机器级表示，我竟然惊喜地发现这一章的内容正是我想学习但一直没找到汇总很好的学习资
      
    
    </summary>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP浮点数</title>
    <link href="http://yoursite.com/2019/05/08/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05-8/"/>
    <id>http://yoursite.com/2019/05/08/CSAPP学习笔记5-8/</id>
    <published>2019-05-08T11:29:20.000Z</published>
    <updated>2019-05-19T04:51:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机系统学习"><a href="#计算机系统学习" class="headerlink" title="计算机系统学习"></a>计算机系统学习</h2><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>为了让数值的表示更加精确，或者表示一些整数无法达到的数字，比如一些接近于0的数字，或者一些非常大的数值就需要用到浮点数了。浮点数对于计算机的意义，可以说是相当之大。<br>IEEE标准采用类似于科学计数法的方式表示浮点小数，即我们将每一个浮点数表示为 V = (-1)^s*M*2^E 。<br>这其中s为符号位，为0时为正，为1时为负。M为尾数，是一个二进制小数，它的范围是0至1-ε，或者1至2-ε（。E为阶码，是一个二进制整数，可正可负，为了给尾数加权。<br>浮点格式分为两种，一种是单精度，一种是双精度。单双精度分别对应于编程语言当中的float和double类型。其中float是单精度的，采用32位二进制表示，其中1位符号位，8位阶码以及23位尾数。double是双精度的，采用64位二进制表示，其中1位符号位，11位阶码以及52位尾数。<br>针对阶码E的值，浮点数的值可以分为三种不同的情况，分别是规格化的，非规格化的以及特殊值。我记得之前在上计算机组成原理课的时候，老师比较年轻生怕我们听不懂，就总让我提问，我曾经就提了一个关于规格化的问题，但具体是什么忘了，人上了岁数总容易忘事。所谓规格化就是E不为0也不为全1，当E为0时就是非规格化，特殊值就是无穷大或者不能表示的数。<br>计算浮点格式的数的值，过程比较简单，按照书上的过程直接算就行，这里就不再写了。</p><h3 id="浮点数的舍入"><a href="#浮点数的舍入" class="headerlink" title="浮点数的舍入"></a>浮点数的舍入</h3><p>针对浮点数来说，我们的舍入方式有四种方式，分别是向偶数舍入、向零舍入、向上舍入以及向下舍入。通常情况下我们采取的舍入规则是在原来的值是舍入值的中间值时，采取向偶数舍入，在二进制中，偶数我们认为是末尾为0的数。而倘若不是这种情况的话，则一般会有选择性的使用向上和向下舍入，但总是会向最接近的值舍入。其实这正是IEEE采取的默认的舍入方式，这种方式在进行数据统计的时候，更加科学一些，50%的概率嘛。</p><h3 id="浮点数的运算"><a href="#浮点数的运算" class="headerlink" title="浮点数的运算"></a>浮点数的运算</h3><p>浮点数的运算比较特殊，不支持加法的结合律，(3.14+1e10)-1e10!=3.14+(1e10-1e10)；也不支持乘法的结合律和分配律,(1e20*1e20)*1e-20!=1e20*(1e20*1e-20),1e20*(1e20-1e20)!=1e20*1e20 +1e20*1e20</p><h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><p>通过本章的学习，了解计算机中对数的表示，不同类型的数有不同的性质。在今后写程序中，也会注意不同类型的数在转换时，运算时的表达形式，尽量避免由于数的某些错误而导致整个程序意想不到的结果。</p><h2 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h2><p>今天在另一台电脑上重新搭静态博客，真是一把辛酸泪，碰到的问题很多，比如图床的问题，还有gitalk的一些问题。等我解决好这些问题，再进行个整理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;计算机系统学习&quot;&gt;&lt;a href=&quot;#计算机系统学习&quot; class=&quot;headerlink&quot; title=&quot;计算机系统学习&quot;&gt;&lt;/a&gt;计算机系统学习&lt;/h2&gt;&lt;h3 id=&quot;浮点数&quot;&gt;&lt;a href=&quot;#浮点数&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP整数的运算</title>
    <link href="http://yoursite.com/2019/05/07/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05-7/"/>
    <id>http://yoursite.com/2019/05/07/CSAPP学习笔记5-7/</id>
    <published>2019-05-07T07:41:26.000Z</published>
    <updated>2019-05-19T04:54:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机系统学习"><a href="#计算机系统学习" class="headerlink" title="计算机系统学习"></a>计算机系统学习</h2><h3 id="整数的运算"><a href="#整数的运算" class="headerlink" title="整数的运算"></a>整数的运算</h3><p>平时的编程过程中，当进行整数运算时，经常会遇到一些奇怪的结果，比如两个正数加出负数，两个负数可以加出一个正数，这些都是由于数值表示的有限性导致的。<br><strong>无符号的加法</strong><br>二进制整数的加法与我们平时的十进制算法有一个最大的区别，那就是我们在计算机当中进行计算时，结果的位数都是有限制的。因此在我们计算过后，可能需要对结果进行截断操作。如果结果用超出规定的位才能表示，就算是溢出。所以来说无符号的加法只要不溢出就可以按照正常的加法来算，但如果出现溢出就需要减2^w。<br><strong>补码的加法</strong><br>对于补码加法就是可以先按照无符号加法进行运算，然后再进行无符号和有符号的转换。<br>与无符号加法不同的是，补码的加法会出现三种结果，一种是正常的结果，一种是正溢出，一种是负溢出。对于当正溢出的时候，我们的结果与无符号数类似，相加后的结果减去2^w。而当负溢出的时候，则刚好相反，相加后的结果加上2^w。<br><strong>补码的非</strong><br>先明白一个概念，对于任意一个w位的补码数t来说，它都有唯一的逆元t^-1，使得t + t^-1 = 0。<br>一个w位的补码数的范围在-2^(w-1）到2^(w-1)之间，直观的可以看出，对于不等于-2^(w-1)的补码数x来说，它的逆元就是-x。而对于-2^(w-1)来说，它的二进制位表示为1后面跟着w-1个0，我们需要找到一个数与其相加之后结果为0。这种时候我们需要考虑的是，如果是-x，也就是2^(w-1)，则它的位表示需要w+1位，是不存在的。因此我们需要考虑溢出的情况,负溢出的时候需要加上2^w，因此-2w-1的逆元就是-2^w + 2^(w-1) = -2^(w-1)，也就是它本身。<br><strong>无符号乘法</strong><br>无符号的乘法与加法类似，它的运算方式是比较简单的，只是也可能产生溢出。对于两个w位的无符号数来说，它们的乘积范围在0到(2^w-1)^2之间，因此可能需要2w位二进制才能表示。因此由于位数的限制，假设两个w位的无符号数的真实乘积为result，根据截断的规则，则实际得到的乘积为 result mod 2^w。<br><strong>补码乘法</strong><br>与加法运算类似，补码乘法也是建立在无符号的基础之上的，因此我们可以很容易的得到，对于两个w位的补码数来说，假设它们的真实乘积为result，则实际得到的乘积为 U2Tw(result mod 2^w)。<br><strong>乘以常数</strong><br>对于一个w位的二进制数来说，它与2^k的乘积，等同于这个二进制数左移k位，在低位补k个0。<br><strong>除以2的幂</strong><br>1.除以2的幂的无符号除法：对于一个w位的二进制数来说，它除以2^k，等同于这个二进制数右移k位，在高位补k个0。<br>2.除以2的幂的补码除法：对于一个w位的非负数的二进制数来说，它除以2^k，等同于这个二进制数右移k位，在高位补k个1；而对于一个w位的负数的二进制数来说，它除以2^k，要先加上2^k-1,然后再右移k位，在高位补k个1。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>计算机执行整数运算实际上是一种模运算形式，由于数字长度的限制，就会出现溢出的现象，这样就会导致程序运行错误，也会出现许多漏洞，比如在分配地址空间时，发生了正溢出，得到的结果比我们预想的小得多，这样就会导致分配的地址空间变小，而对这些空间进行某些操作时，会破坏超出这些地址空间的数据。</p><h2 id="地址传送指令"><a href="#地址传送指令" class="headerlink" title="地址传送指令"></a>地址传送指令</h2><table><thead><tr><th style="text-align:center">指令格式</th><th style="text-align:center">名称</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">lea r16,mem</td><td style="text-align:center">有效地址传送指令</td><td style="text-align:center">r16&lt;-mem的有效地址</td></tr><tr><td style="text-align:center">lds r16,mem</td><td style="text-align:center">指针传送指令</td><td style="text-align:center">r16&lt;-mem，DS&lt;-mem+2</td></tr><tr><td style="text-align:center">les r16,mem</td><td style="text-align:center">指针传送指令</td><td style="text-align:center">r16&lt;-mem,ES&lt;-mem+2</td></tr></tbody></table><p>LEA指令将存储器操作数mem的4位16进制偏移地址送到指定的寄存器。这里，源操作数必须是存储器操作数，目标操作数必须是16位通用寄存器。对于LEA指令来说变量其后面的有无[]皆可，都表示取变量地址，相当于指针；寄存器无[]表示取地址，有[]表示取值。<br>lds和les的操作过程差不多，r16是一个16位寄存器,mem是一个存储器操作数,为双字项,高16位送入DS/ES,低16位送入r16.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;计算机系统学习&quot;&gt;&lt;a href=&quot;#计算机系统学习&quot; class=&quot;headerlink&quot; title=&quot;计算机系统学习&quot;&gt;&lt;/a&gt;计算机系统学习&lt;/h2&gt;&lt;h3 id=&quot;整数的运算&quot;&gt;&lt;a href=&quot;#整数的运算&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP整数的拓展与截断</title>
    <link href="http://yoursite.com/2019/05/06/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05-6/"/>
    <id>http://yoursite.com/2019/05/06/CSAPP学习笔记5-6/</id>
    <published>2019-05-06T08:56:38.000Z</published>
    <updated>2019-05-19T04:53:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机系统学习"><a href="#计算机系统学习" class="headerlink" title="计算机系统学习"></a>计算机系统学习</h2><p>今天学习了对二进制整数的位进行拓展和截断表示。</p><h3 id="拓展数字"><a href="#拓展数字" class="headerlink" title="拓展数字"></a>拓展数字</h3><p style="text-indent:2em">假如我们将一个短整型的变量转换为整型变量，由两个字节扩充为四个字节，这时就涉及到了位的扩展。</p><br><p style="text-indent:2em">在进行位的扩展时，最容易想到的就是在高位全部补0，也就是将原来的二进制序列前面加入若干个0，也称为零扩展。还有一种方式比较特别，是符号扩展，也就是针对有符号数的方式，它是直接扩展符号位，也就是将二进制序列的前面加入若干个最高位。</p><br><p style="text-indent:2em">对于零扩展来说，很明显扩展之后的值与原来的值是相等的，而对于符号扩展来说，则是一样，只不过没有零扩展来的直接。我们在计算补码时有一个比较简单的办法，就是符号位若为0，则与无符号是类似的。若符号位为1，也就是负数时，可以将其余位取反最终再加1即可。因此当我们对一个有符号的负数进行符号扩展时，前面加入若干个1，在取反之后都为0，因此依旧会保持原有的数值。</p><br><p style="text-indent:2em">总之，在对位进行扩展时，是不会改变原有数值的。</p><br><p style="text-indent:2em">在书中对于负数的符号扩展还给出了这一过程的证明，这个证明使用了数学归纳法，具体过程如下。</p><br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g2rpns18k4j30gh08iglv.jpg" alt><br><p style="text-indent:2em">2的幂函数有一个特殊的属性，就是2^w-2^(w-1)=2^(w-1).因此加上一个权值为-2^w的位，和一个将权值为-2^(w-1)的位转为权值为2^(w-1)的位，这两项综合起来得到的结果是一样的。</p><h3 id="截断数字"><a href="#截断数字" class="headerlink" title="截断数字"></a>截断数字</h3><p></p><p style="text-indent:2em">截断与扩展相反，它是将一个多位二进制序列截断至较少的位数，也就是与扩展是相反的过程。</p><br>观察书中给的例子，我们可以发现截断可能会导致数据的失真。对于无符号编码来说，截断后就是剩余位数的无符号编码数值。在书中给出了这一简单过程的证明，它主要是想表明截断前与截断后的数值的关系是取余数所得到的。而对于有符号数来说，就是在截断无符号数的基础上加上一步，做一个无符号数转补码的操作。总的来说，无符号数的截断结果是<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g2rpzcjdebj30gi014jra.jpg" alt><br>而补码数字的截断结果是<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g2rq05yaqtj30gs01eq2v.jpg" alt><br>我在做习题2.24时卡了好久，自己做的结果和答案就是对不上，后来才发现题目要求将4位截断位3位，我一直以为是2位，做了半天好心酸。比如对于-1来说，二进制补码表示为1111，首先按截断的位数取余得到无符号数111，再将无符号数转为补码，按照昨天的公式得到7-8=-1.<p></p><h3 id="关于有无符号数转换的思考"><a href="#关于有无符号数转换的思考" class="headerlink" title="关于有无符号数转换的思考"></a>关于有无符号数转换的思考</h3><p>从上面的分析不难看出，具有有符号和无符号数的语言，在相互转换时可能会因此引起一些不必要的麻烦。而且无符号数除了能表示的最大值更大以外，似乎并没有太大的好处，因此有很多语言是不支持无符号数的。在Java语言中，就只有有符号数，这样省去了很多不必要的麻烦。<br>有符号数和无符号数在进行强制转换时可能会引起程序的错误，而当这种转换是隐式的时候，错误很难被发现，因而程序会得出莫名其妙的结果。很多函数也因为这种强制转换而存在漏洞，被有心人利用，比如getpeername函数，如果对一个补码的最小值按照无符号数来读，这样就会读出一个很大的数值，如果这个值代表一个地址，那么就可能会产生越界或者读到一些不被授权的信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;计算机系统学习&quot;&gt;&lt;a href=&quot;#计算机系统学习&quot; class=&quot;headerlink&quot; title=&quot;计算机系统学习&quot;&gt;&lt;/a&gt;计算机系统学习&lt;/h2&gt;&lt;p&gt;今天学习了对二进制整数的位进行拓展和截断表示。&lt;/p&gt;
&lt;h3 id=&quot;拓展数字&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP整数的表示</title>
    <link href="http://yoursite.com/2019/05/05/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05-5/"/>
    <id>http://yoursite.com/2019/05/05/CSAPP学习笔记5-5/</id>
    <published>2019-05-05T08:25:18.000Z</published>
    <updated>2019-05-19T04:54:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机系统学习"><a href="#计算机系统学习" class="headerlink" title="计算机系统学习"></a>计算机系统学习</h2><p>今天学习了整数的表示，一般编码整数有两种方式：一种只能表示非负数，而另一种能够表示负数、零和整数。这样就把整数分为无符号数unsigned和有符号数int(默认)，通过今天的学习初步掌握了几种编码类型和它们之间的转换。</p><h3 id="编码类型"><a href="#编码类型" class="headerlink" title="编码类型"></a>编码类型</h3><p><strong>无符号编码</strong><br>其实无符号编码就是我们平时最直接的读法，没有符号位，直接可以转换位十进制数。对于一个w位的二进制数来说，取值范围是[0,2^w-1]。<br><strong>补码</strong><br>无符号编码读起来直接自然，但是可惜的是，它无法表示负整数。因此我们需要一种能够表示负数的整数表示方式，这样就引出了补码编码。补码表示的二进制数，最高位是符号位，0为非负数，1为负数。补码的定义如下<br><img src="https://tva1.sinaimg.cn/large/007rAy9hly1g2qj6it8yfj30a901s0sk.jpg" alt><br>我们观察这个公式，不难看出，补码格式下，对于一个w位的二进制序列来说，当最高位为1，其余位全为0时，得到的就是补码格式的最小值，即TMinw = -2^w-1;而当最高位为0，其余位全为1时，得到的就是补码格式的最大值，即TMaxw = 2^(w-1)-1<br><strong>反码和原码</strong><br>有符号数还有两种表示方法：反码和原码<br>反码和补码的区别在于，除了最高有效位的权是-[2^(w-1)-1]而不是-2^(w-1)],它们没有别的区别。<br>而原码，最高有效位是符号位，仅用来确定正负，剩下的位是具体的数，按照我们平时的读法来读就可以。</p><h3 id="不同编码的转换"><a href="#不同编码的转换" class="headerlink" title="不同编码的转换"></a>不同编码的转换</h3><p>在C语言当中，我们经常会使用强制类型转换，而在之前的章节中，也学习过强制类型转换。强制类型转换不会改变二进制序列，但是会改变数据类型的大小以及解释方式，那么考虑相同整数类型的无符号编码和补码编码，数据类型的大小是没有任何变化的，变化的就是它们的解释方式。比如1001这个二进制序列，如果用无符号编码解释的话就是表示9，而若采用补码编码解释的话，则是表示-7。<br><strong>补码转无符号数</strong><br>通过分析书上的例子，总结出一条规律就是，假设补码表示的数为x，当x&lt;0时为x+2^w,当x&gt;=0为x。为什么会得出来这样的结果？主要是因为最高位是否为符号位而产生的差异。<br><strong>无符号数转补码</strong><br>无符号数转补码同样有规律，同样设无符号数为x，当x&lt;=TMaxw时，为x，当x&gt;TMaxw时，为x-2^w.得出这样的结果原因同上。<br>C语言中的有符号数和无符号数可以通过隐式转换或者显式转换的方式实现。</p><h2 id="堆栈操作指令"><a href="#堆栈操作指令" class="headerlink" title="堆栈操作指令"></a>堆栈操作指令</h2><table><thead><tr><th style="text-align:center">指令格式</th><th style="text-align:center">名称</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">push reg/mem/seg</td><td style="text-align:center">进栈指令</td><td style="text-align:center">SP&lt;-SP-2,[sp]&lt;-reg/mem/seg</td></tr><tr><td style="text-align:center">pop reg/mem/seg</td><td style="text-align:center">出栈指令</td><td style="text-align:center">reg/mem/seg&lt;-[sp],SP&lt;-SP+2</td></tr></tbody></table><h3 id="PUSH"><a href="#PUSH" class="headerlink" title="PUSH"></a>PUSH</h3><p>PUSH指令即先修改堆栈指针SP(压入时为自动减2),然后将指定的操作数送入新的栈顶位置。push的操作过程可以用下面的代码来表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUSH:</span><br><span class="line">R[$SP]= R[$SP]-2; </span><br><span class="line">badStack(R[$SP],R[$IP]);</span><br><span class="line">RAM[R[$SP]] = R[RAM[R[$IP]+1]];</span><br><span class="line">R[$IP]=R[$IP]+2;</span><br></pre></td></tr></table></figure></p><h3 id="POP"><a href="#POP" class="headerlink" title="POP"></a>POP</h3><p>POP指令和PUSH指令是相对而言的，POP指令是将堆栈段中当前SS:SP所指的字内容弹出到某个寄存器或段寄存器或内存单元，然后再修改堆栈指针SP，指向新的栈顶。POP的操作过程可以用下面的代码来表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POP:</span><br><span class="line">R[RAM[R[$IP]+1]]=RAM[R[$SP]]);</span><br><span class="line">R[$SP]=R[$SP]+2;</span><br><span class="line">badStack(R[$SP],R[$IP]);</span><br><span class="line">R[$IP] = R[$IP]+2;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;计算机系统学习&quot;&gt;&lt;a href=&quot;#计算机系统学习&quot; class=&quot;headerlink&quot; title=&quot;计算机系统学习&quot;&gt;&lt;/a&gt;计算机系统学习&lt;/h2&gt;&lt;p&gt;今天学习了整数的表示，一般编码整数有两种方式：一种只能表示非负数，而另一种能够表示负数、零和整数。这
      
    
    </summary>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统学习</title>
    <link href="http://yoursite.com/2019/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/05/03/计算机系统学习/</id>
    <published>2019-05-03T07:12:43.000Z</published>
    <updated>2019-05-24T13:17:48.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="虚拟机指令集架构"><a href="#虚拟机指令集架构" class="headerlink" title="虚拟机指令集架构"></a>虚拟机指令集架构</h2><p style="text-indent:2em">所谓指令集，就是CPU中用来计算和控制计算机系统的一套指令的集合。因为指令集表示了一个给定的CPU能做哪些工作，所以在设计一个机器时考虑需要提供什么样的指令是非常重要的步骤。实际上总会有一些基本指令，所有的处理器、虚拟机或运行时环境都会提供，比如算术运算、逻辑运算、位操作、比较运算、跳转等。CPU的指令集从主流的体系结构上分为精简指令集RISC和复杂指令集CISC，CISC指令系统庞大，指令功能复杂，指令格式、寻址方式多；而RISC指令数量少，大部分为单周期指令，操作寄存器，只有Load/Store操作内存。</p><br><p style="text-indent:2em">在设计指令集时，除了考虑RISC和CISC之外，还需要考虑指令集的正交性。如果一个指令集是均匀平衡的，就可以认为它是正交的。正交性可以扩展某些指令的功能，使之与逻辑上同组的其他指令相对，比如加法指令和减法指令。</p><br><p style="text-indent:2em">一个基本的指令集可分为算术运算类指令、逻辑运算类指令、数据传送指令、程序控制指令、串操作指令、浮点运算指令和数据转换指令等。在myvm的指令集中，已经初步分析处算术运算类指令、逻辑运算类指令和程序转移指令，并且发现它们是成组出现的。继续分析时发现判断不出来指令，感觉对数据传送指令和串操作指令不熟悉，之后会对这些类别的指令的执行过程和原理进行了解。</p><h2 id="深入理解计算机系统"><a href="#深入理解计算机系统" class="headerlink" title="深入理解计算机系统"></a>深入理解计算机系统</h2><p>继续阅读《深入理解计算机系统》第1章，主要了解存储器的层次结构和操作系统的相关内容。</p><p><strong>存储器的层次结构</strong><br>1.层次化结构：CPU–寄存器–Cache–主存–辅存<br>存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。<br>2.分类方式<br>按存取方式分：随机存储器(在程序的执行过程中可读可写)、只读存储器(在程序的执行过程中只读)、串行访问存储器(如磁带是顺序访问存储器，硬盘是直接访问存储器)<br>按层次划分：主存储器即内存、辅存储器即硬盘等、高速缓存Cache<br>按信息可保护性分：断电易失如RAM、断电不丢失如ROM、破坏性读如DRAM、非破坏性读如SRAM<br>3.性能指标<br>实际容量=存储单元个数 <em> 单元长度；理论容量=存储字数 </em> 存储字长<br>存取时间=取出结果时间-启动存储器时间<br>存取周期=存取时间+存储器状态恢复时间=连续读或写的最小时间间隔，显然存取周期&gt;=存取时间<br>主存带宽=传输速率=每秒能传输多少bit</p><p><strong>操作系统</strong><br>1.操作系统是什么？<br>操作系统是用户和计算机的接口，同时也是计算机硬件和其他软件的接口。操作系统的功能包括管理计算机系统的硬件、软件及数据资源，控制程序运行，改善人机界面，为其它应用软件提供支持等，使计算机系统所有资源最大限度地发挥作用，提供了各种形式的用户界面，使用户有一个好的工作环境，为其它软件的开发提供必要的服务和相应的接口。实际上，用户是不用接触操作系统的，操作系统管理着计算机硬件资源，同时按着应用程序的资源请求，为其分配资源，如：划分CPU时间，内存空间的开辟，调用打印机等。<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g2oa3g3c52j306y0aa74v.jpg" alt><br>2.操作系统中有几个基本的抽象概念<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g2oa3r62vmj30c305f74b.jpg" alt><br>(1)进程是操作系统对一个正在运行的程序的抽象。操作系统会记录每一个进程的状态，这些状态就称作进程的上下文。这些状态主要包括了PC，寄存器以及主存的当前内容。当操作系统在进程间切换的时候，也会切换相应的上下文，从而保证进程恢复到之前的状态。<br>在进程当中，又被计算机界的大神们引入了线程的概念，这些线程可以共享进程级的代码与数据，这种共享一般比进程间的共享更加高效。<br>(2)虚拟存储器是一种抽象描述，从物理上讲，它包含了I/O设备以及主存。在逻辑上讲，虚拟存储器被描述为虚拟地址空间。下图为进程的虚拟地址空间表示。<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g2oa456l7cj30f30bft9c.jpg" alt><br>这里的地址自下向上依次增大，可以看出，图中标注了起始地址，分别为0x08048000（32位）以及0x00400000（64位），然后向上分别是只读代码和数据、读写数据、运行时堆、共享库的内存映射区间、用户栈以及内核虚拟内存区域。<br>(3)文件是I/O设备逻辑上的概念，它其实就是字节序列，也就是1和0组成的一些信息。因此所有的I/O设备，包括磁盘、键盘、鼠标、显示器都可以看成是文件。<br>所有的I/O设备其实都是文件这一抽象概念的具体表现，那么网络其实也是文件的一种，因为说到底，它也可以被看做是一系列的字节序列。网络适配器的作用就是给计算机输入一堆被传送过来的字节序列，这里面可能包括图片、文字，甚至可能是代码等等。<br>3.操作系统的特征<br>(1)并发:操作系统的并发性是指计算机系统中同时存在多个运行着的程序，因此它具有处理和调度多个程序同时执行的能力。<br>(2)共享:资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。<br>(3)虛拟:在操作系统中利用了多种虚拟技术，分别用来实现虚拟处理器、虚拟内存和虚拟外部设备等。<br>(4)异步:在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;虚拟机指令集架构&quot;&gt;&lt;a href=&quot;#虚拟机指令集架构&quot; class=&quot;headerlink&quot; title=&quot;虚拟机指令集架构&quot;&gt;&lt;/a&gt;虚拟机指令集架构&lt;/h2&gt;&lt;p style=&quot;text-indent:2em&quot;&gt;所谓指令集，就是CPU中用来计算和控制计算机
      
    
    </summary>
    
    
      <category term="304反汇编测试" scheme="http://yoursite.com/tags/304%E5%8F%8D%E6%B1%87%E7%BC%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>304Challenge:代码分析5</title>
    <link href="http://yoursite.com/2019/05/02/304Challenge-%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%905/"/>
    <id>http://yoursite.com/2019/05/02/304Challenge-代码分析5/</id>
    <published>2019-05-02T11:38:35.000Z</published>
    <updated>2019-05-24T13:19:13.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>1.在汇编代码中，发现有很多[],[]表示是间接寻址，bx和[bx]的区别是，前者操作数就是bx中存放的数，后者操作数是以bx中存放的数为地址的单元中的数。<br>比如：mov ax,[bx]<br>bx中存放的数是40F6H，40F6H、40F7H两个单元中存放的数是22H、23H，则<br>mov ax,[bx]；2322H传送到ax中<br>mov ax,bx；40F6H传送到ax中</p><p>2.movzx指令一般用于将较小值拷贝到较大值中，其实就是将我们的源操作数取出来,然后置于目的操作数,目的操作数其余位用0填充。<br>比如eax=00304000h<br>若执行 movzx eax, ax后 eax = 00004000h.<br>若执行 movzx eax, ah后 eax = 00000040h.</p><p>3.SI（Source Index）：源变址寄存器可用来存放相对于DS段之源变址指针；<br>DI（Destination Index）：目的变址寄存器，可用来存放相对于 ES 段之目的变址指针。<br>ROL DEST，COUNT<br>把目的地址中的数据循环左移COUNT次，每次从最高位（最左）移出的数据位都补充到最低位（最右），最后从最高位（最左）移出的数据位保存到CF标志位。</p><p>4.寄存器<br>8086处理器中的寄存器分为8组，每组宽度为32位<br>通用寄存器、段寄存器、指令寄存器、标志寄存器、系统地址寄存器、控制寄存器、调试寄存器、测试寄存器<br>通用寄存器：<br>    EAX 累加器 在乘法和除法指令中被自动使用<br>    EBX 基址寄存器<br>    ECX 计数器 循环计数器<br>    EDX 数据寄存器<br>    ESI 源变址寄存器<br>    EDI 目的变址寄存器<br>    EBP 扩展基址指针寄存器 由高级语言用来引用函数参数和局部变量<br>    ESP 栈指针寄存器<br>EAX EBX ECX EDX ESI EDI EBP ESP #32位<br>AX BX CX DX SI DI BP SP #低16位<br>AH BH CH DH #高8位<br>AL BL CL DL #低8位</p><p>段寄存器：<br>   CS：代码段(Code Segment)<br>   DS：数据段(Data Segment)<br>   ES：附加数据段(Extra Segment)<br>   SS：堆栈段(Stack Segment)<br>   FS：附加段<br>   GS 附加段</p><p>指令寄存器：<br>EIP 指令指针寄存器，低16位为IP（8086），它存储的是下一条要执行指令的地址。</p><p>标志寄存器：<br>    IOPL(I/O Privilege Level) I/O特权级字段，它的宽度为2bit,它指定了I/O指令的特权级。如果当前的特权级别在数值上小于或等于IOPL，那么I/O指令可执行。否则，将发生一个保护性异常。<br>    NT(Nested Task): 控制中断返回指令IRET,它宽度为1位。NT=0,用堆栈中保存的值恢复EFLAGS，CS和EIP从而实现中断返回；NT=1，则通过任务切换实现中断返回。<br>    RF(Restart Flag): 重启标志，它的宽度是1位。它主要控制是否接受调试故障。RF=0接受，RF=1忽略。如果你的程序每一条指令都被成功执行，那么RF会被清0。而当接受到一个非调试故障时，处理器置RF=1。<br>    VM(Virtual Machine): 虚拟8086模式(用软件来模拟8086的模式，所以也称虚拟机)。VM=0,处理器工作在一般的保护模式下；VM=1，工作在V8086模式下。<br>    其它16个标志位的含义和8086一样：<br>    CF(Carry Flag): 进位标志位，由CLC，STC两标志位来控制，在无符号算数运算的结果无法容纳于目的操作数中时被设置<br>    PF(Parity Flag): 奇偶标志位<br>    AF(Assistant Flag): 辅助进位标志位<br>    ZF(Zero Flag): 零标志位<br>    SF(Singal Flag): 符号标志位<br>    IF(Interrupt Flag): 中断允许标志位,由CLI，STI两条指令来控制<br>    DF(Direction Flag): 向量标志位，由CLD，STD两条指令来控制<br>    OF(Overflow Flag): 溢出标志位</p><p>PSW（Program Flag)程序状态字寄存器，是一个16位寄存器，由条件码标志（flag）和控制标志构成<br>    OF（Overflow Flag)溢出标志。溢出时为1,否则置0<br>    SF（Sign Flag）符号标志。结果为负时置1,否则置0<br>    ZF（Zero Flag)零标志，运算结果为0时ZF位置1,否则置0<br>    CF（Carry Flag)进位标志，进位时置1,否则置0<br>    AF（Auxiliary carry Flag）辅助进位标志，记录运算时第3位（半个字节）产生的进位置。有进位时1,否则置0<br>    PF（Parity Flag）奇偶标志。结果操作数中1的个数为偶数时置1,否则置0<br>    DF（Direction Flag）方向标志，在串处理指令中控制信息的方向<br>    IF（Interrupt Flag）中断标志<br>    TF（Trap Flag）陷井标志</p><h2 id="深入理解计算机系统"><a href="#深入理解计算机系统" class="headerlink" title="深入理解计算机系统"></a>深入理解计算机系统</h2><p>今天读了《深入理解计算机系统》第1章部分，通过一个hello程序执行过程来进行对计算机系统的学习。<br><strong>hello程序的生命周期</strong><br>源程序hello.c-&gt;(预处理器)-&gt;修改的源程序hello.i-&gt;(编译器)-&gt;汇编程序hello.s-&gt;(汇编器)-&gt;可重定位目标程序hello.o+printf.o-&gt;(链接器)-&gt;可执行目标程序hello<br>printf函数存放于printf.o中，它是每个C编译器都会提供的标准库中的一个函数。<br>通过这样一个简单的程序来了解编译系统是如何工作的，理解编译系统是大有益处的，它可以帮助我们优化程序性能、理解链接时出现的错误、避免安全漏洞。<br><strong>计算机系统的硬件组成</strong><br>总线：携带信息字节并负责在各个部件间传递。<br>I/O设备：系统与外部世界连接的通道，比如鼠标、键盘、磁盘都属于输入输出设备。<br>主存：在处理器执行程序时，用来存放程序和程序处理的数据。<br>处理器：解释执行存储在主存中指令的引擎。<br>随着近些年半导体技术的发展，加快处理器的运行速度比加快主存的运行速度要容易和便宜的多，处理器和主存之间的差距不断增大，为了减少这种差异所带来的影响，加入了一种高速缓存机制。高速缓冲存储器是存在于主存与CPU之间的一级存储器， 由静态存储芯片(SRAM)组成，容量比较小但速度比主存高得多，接近于CPU的速度。由局部性原理可以知道，在CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。通过让高速缓存里存放可能经常访问的数据的方法，可以大幅度提高提升程序执行的速度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;代码分析&quot;&gt;&lt;a href=&quot;#代码分析&quot; class=&quot;headerlink&quot; title=&quot;代码分析&quot;&gt;&lt;/a&gt;代码分析&lt;/h2&gt;&lt;p&gt;1.在汇编代码中，发现有很多[],[]表示是间接寻址，bx和[bx]的区别是，前者操作数就是bx中存放的数，后者操作数是以b
      
    
    </summary>
    
    
      <category term="304反汇编测试" scheme="http://yoursite.com/tags/304%E5%8F%8D%E6%B1%87%E7%BC%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>304Challenge:代码分析4</title>
    <link href="http://yoursite.com/2019/04/30/304Challenge-%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%904/"/>
    <id>http://yoursite.com/2019/04/30/304Challenge-代码分析4/</id>
    <published>2019-04-30T12:35:11.000Z</published>
    <updated>2019-05-24T13:19:03.092Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sub-E90代码分析"><a href="#sub-E90代码分析" class="headerlink" title="sub_E90代码分析"></a>sub_E90代码分析</h2><p>今天分析到case 151、case 152卡了，没有做上匹配，先来说一下我的理解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000000EF3                 movzx   eax, word ptr [rbx+22h]</span><br><span class="line">.text:0000000000000EF7                 add     eax, 0FFFFFFFEh</span><br><span class="line">.text:0000000000000EFA                 mov     [rbx+22h], ax</span><br><span class="line">.text:0000000000000EFE                 movzx   edx, ax</span><br><span class="line">.text:0000000000000F01                 cmp     edx, 7FFDh</span><br><span class="line">.text:0000000000000F07                 jnb     loc_13CF</span><br><span class="line">.text:0000000000000F0D                 rol     di, 8</span><br><span class="line">.text:0000000000000F11                 mov     [rcx+rdx], di</span><br><span class="line">.text:0000000000000F15                 cmp     byte ptr [r15], 27h </span><br><span class="line">.text:0000000000000F19                 jnz     loc_139F</span><br><span class="line">.text:0000000000000F1F                 movzx   eax, word ptr [r15+2]</span><br><span class="line">.text:0000000000000F24                 rol     ax, 8</span><br><span class="line">.text:0000000000000F28                 add     [rbx+1Eh], ax</span><br><span class="line">.text:0000000000000F2C                 jmp     loc_EA6</span><br></pre></td></tr></table></figure></p><p>EAX和AX存在某种联系，EAX与AX不是独立的，EAX是32位的寄存器，而AX是EAX的低16位。<br>举例来说mov eax, FFFFFFFEh，那么AX将会是eax的低16位，也就是FFFEh。<br>而如果此时mov ax，3344h，那么eax的值将变为FFFF3344h，所以对ax的赋值是会影响eax的。<br>同样，AH是ax的高8位，而AL是ax的低8位，这就是说ah为33h，al为44h。<br>在EFE处，将ax的数据传送给edx，之后和7FFDh作比较，不低于7FFDh就直接退出了。接下来操作数和39比，不等于跳loc_139F，两种情况做的处理形式差不多。我猜想此功能是对操作数做一个if-else处理，但如果是这样的话就是一个复合的汇编指令了，或者是我没见过的汇编指令，还需要继续查资料。</p><h2 id="其他辅助解题的资料"><a href="#其他辅助解题的资料" class="headerlink" title="其他辅助解题的资料"></a>其他辅助解题的资料</h2><p><strong>虚拟寄存器</strong><br>VMRE共有40个寄存器，包括5个段寄存器、5个指针寄存器、10个通用寄存器、 10个双精度寄存器和10个单精度寄存器，如图I所示 。其中，段寄存器把地址空间划分成不同的地址段 ；指针寄存器用来记录指令地址和保存堆栈地址的，例如 ：IP是指令指针 ；SP是堆栈指针 ；BP是基址指针；通用数据寄存器是用来存储64位整型数的；双精度寄存器是用来存储64位双精度的浮点数；单精度寄存器是用来存储32位单精度的浮点数。<br><strong>虚拟内存的设计和管理</strong><br>在VMRE设计中，通过一个字符串指针来开辟一块连续的内存地址作为虚拟 内存空间，存储程序的字节码指令。由于在32位机器上无法提供这么多的物理内存，因此VMRE采用先预读后分配的原则来开辟 虚拟内存，即先对字节码文件的大小进行预读，根据其大小再从物理内存中分配足够的内存作为虚拟内存 ，如果剩余的物理内存无法满足需要 ，则退出该次分配。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;sub-E90代码分析&quot;&gt;&lt;a href=&quot;#sub-E90代码分析&quot; class=&quot;headerlink&quot; title=&quot;sub_E90代码分析&quot;&gt;&lt;/a&gt;sub_E90代码分析&lt;/h2&gt;&lt;p&gt;今天分析到case 151、case 152卡了，没有做上匹配，先来
      
    
    </summary>
    
    
      <category term="304反汇编测试" scheme="http://yoursite.com/tags/304%E5%8F%8D%E6%B1%87%E7%BC%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Web:BasicFileInclude</title>
    <link href="http://yoursite.com/2019/04/29/Web-BasicFileInclude/"/>
    <id>http://yoursite.com/2019/04/29/Web-BasicFileInclude/</id>
    <published>2019-04-29T12:08:25.000Z</published>
    <updated>2019-04-29T12:14:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BasicFileInclude"><a href="#BasicFileInclude" class="headerlink" title="BasicFileInclude"></a>BasicFileInclude</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>看到题目，可以知道这是一个文件包含漏洞的题，打开网址有两个活动页面(Home、Flag),很明显要找的东西在Flag页面。点击Flag页面，出现一句话”ha ha? you want flag? flag is here, but don’t let you see! “flag的内容被隐藏了，要想获取隐藏的信息就需要使用php伪协议，比如说经常使用的伪协议php://filter，一般用于任意文件读取。<br>php://filter有以下几个参数：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">resource=&lt;要过滤的数据流&gt;</td><td style="text-align:left">这个参数是必须的。它指定了你要筛选过滤的数据流。</td></tr><tr><td style="text-align:center">read=&lt;读链的筛选列表&gt;</td><td style="text-align:left">该参数可选。可以设定一个或多个过滤器名称，以管道符分隔</td></tr><tr><td style="text-align:center">write=&lt;写链的筛选列表&gt;</td><td style="text-align:left">该参数可选。可以设定一个或多个过滤器名称，以管道符分隔</td></tr><tr><td style="text-align:center">&lt;；两个链的筛选列表&gt;</td><td style="text-align:left">任何没有以read=或write= 作前缀的筛选器列表会视情况应用于读或写链。</td></tr></tbody></table><pre><code>php://filter/[read/write]=string.[rot13/strip_tags/…..]/resource=xxx</code></pre><p>filter和string过滤器连用可以对字符串进行过滤。filter的read和write参数有不同的应用场景。read用于include()和file_get_contents(),write用于file_put_contents()中。</p><pre><code>php://filter/convert.base64-[encode/decode]/resource=xxx</code></pre><p>这是使用的过滤器是convert.base64-encode.它的作用就是读取upload.php的内容进行base64编码后输出。可以用于读取程序源代码经过base64编码后的数据。<br>根据上面的构造方法首先构造</p><pre><code>http://123.207.149.64:23338/?page=php://filter/resource=flag</code></pre><p>发现是没有反应的，其实是php语法文件include成功，直接运行。想要检查php的源文件，可以先base64编码，再传入include函数，这样就不会被认为是php文件，不会执行，会输出文件的base64编码，再解码即可。<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g2icomqiv6j30ht01o3yf.jpg" alt><br>得到Base64编码后的信息，进行解码后得到php源码。<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g2icpwtc3cj30fv03dweh.jpg" alt></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>PHP支持的伪协议<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">file:// — 访问本地文件系统</span><br><span class="line">http:// — 访问 HTTP(s) 网址</span><br><span class="line">ftp:// — 访问 FTP(s) URLs</span><br><span class="line">php:// — 访问各个输入/输出流（I/O streams）</span><br><span class="line">zlib:// — 压缩流</span><br><span class="line">data:// — 数据（RFC 2397）</span><br><span class="line">glob:// — 查找匹配的文件路径模式</span><br><span class="line">phar:// — PHP 归档</span><br><span class="line">ssh2:// — Secure Shell 2</span><br><span class="line">rar:// — RAR</span><br><span class="line">ogg:// — 音频流</span><br><span class="line">expect:// — 处理交互式的流</span><br></pre></td></tr></table></figure></p><p>php://访问输入输出流，除了本题用到的php://filter，还有一个子协议是php://input：<br>php://input可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行。当传入的参数作为文件名打开时，可以将参数设为php://input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。<br>注：当enctype=”multipart/form-data”时，php://input是无效的。</p><p>file://    与php:filter类似，访问本地文件，但是只能传入绝对路径<br>phar://    PHP 归档，常常跟文件包含，文件上传结合着考察。说通俗点就是php解压缩包的一个函数，解压的压缩包与后缀无关。<br>zip://,bzip2://, zlib://     和phar://一样用于读取压缩文件，不过对于”zip://test.zip#file.txt”中的”#”要编码为”%23”.因为url的#后的内容不会被传送。<br>data://text/plain;base64,base编码字符串      很常用的数据流构造器，将读取后面base编码字符串后解码的数据作为数据流的输入。<br>上面就是一些php伪协议在CTF中的常见应用，可以根据具体的情况使用这些伪协议来帮助解题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;BasicFileInclude&quot;&gt;&lt;a href=&quot;#BasicFileInclude&quot; class=&quot;headerlink&quot; title=&quot;BasicFileInclude&quot;&gt;&lt;/a&gt;BasicFileInclude&lt;/h2&gt;&lt;h3 id=&quot;解题思路&quot;&gt;&lt;a 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>304Challenge:代码分析3</title>
    <link href="http://yoursite.com/2019/04/28/304Challenge-%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%903/"/>
    <id>http://yoursite.com/2019/04/28/304Challenge-代码分析3/</id>
    <published>2019-04-28T05:54:48.000Z</published>
    <updated>2019-05-24T13:18:56.406Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sub-E90代码分析"><a href="#sub-E90代码分析" class="headerlink" title="sub_E90代码分析"></a>sub_E90代码分析</h2><p>继续分析接下来的switch分支情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  case 144:</span><br><span class="line">        goto LABEL_38;</span><br><span class="line">      case 145:</span><br><span class="line">        if ( !*((_DWORD *)v1 + 10) )</span><br><span class="line">          goto LABEL_38;</span><br><span class="line">        return v2;</span><br><span class="line">      case 146:</span><br><span class="line">        if ( !*((_DWORD *)v1 + 10) )</span><br><span class="line">          return v2;</span><br><span class="line">        goto LABEL_38;</span><br><span class="line">      case 147:</span><br><span class="line">        if ( *((_DWORD *)v1 + 10) &lt; 0 )</span><br><span class="line">          goto LABEL_38;</span><br><span class="line">        return v2;</span><br><span class="line">      case 148:</span><br><span class="line">        if ( *((_DWORD *)v1 + 10) &lt;= 0 )</span><br><span class="line">          goto LABEL_38;</span><br><span class="line">        return v2;</span><br><span class="line">      case 149:</span><br><span class="line">        if ( *((_DWORD *)v1 + 10) &lt;= 0 )</span><br><span class="line">          return v2;</span><br><span class="line">        goto LABEL_38;</span><br><span class="line">      case 150:</span><br><span class="line">        if ( *((_DWORD *)v1 + 10) &gt;= 0 )</span><br><span class="line">LABEL_38:</span><br><span class="line">          *((_WORD *)v1 + 15) = __ROL2__(*((_WORD *)v7 + 1), 8) + v8;</span><br><span class="line">        return v2;</span><br></pre></td></tr></table></figure></p><p>其实可以看出这些情况主要负责执行控制指令，JMP、JZ、JNZ、JG、JS、JNS这些指令。<br>对于144，执行的是无条件跳转指令JMP，跳转到相应的地址。<br>145，执行的是等于零则跳转指令JZ，跳转到相应的地址。<br>146，执行的是不等于零则跳转指令JNZ，跳转到相应的地址。<br>147，执行的是负号则跳转指令JS，跳转到相应的地址。<br>148，执行的是不大于0则跳转指令JNG，跳转到相应的地址。<br>149，执行的是大于0则跳转指令JG，跳转到相应的地址。<br>150，执行的是非负则跳转指令JNS，跳转到相应的地址。<br>只看这些伪代码是分析不出来具体指令的，比如说当和0比较的时候，如何区别JS和JL呢，在这时就要结合汇编代码一起看了，看IDA文本视图，就别看IDA图形视图了，找线和框框容易找哭。文本视图里case的情况都是集中在一起的，更容易分析。然后根据汇编代码确定出具体的指令，拿伪代码做验证，这样就可以了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>先来总结今天遇到的汇编代码</p><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">含义</th><th style="text-align:center">操作码</th></tr></thead><tbody><tr><td style="text-align:center">JMP $R</td><td style="text-align:center">跳转到$R给出的地址</td><td style="text-align:center">32</td></tr><tr><td style="text-align:center">JZ $R1,$R2,$R3</td><td style="text-align:center">如果$R1=$R2，跳转到R3给出的地址</td><td style="text-align:center">33</td></tr><tr><td style="text-align:center">JNZ $R1,$R2,$R3</td><td style="text-align:center">如果$R1!=$R2，跳转到R3给出的地址</td><td style="text-align:center">34</td></tr><tr><td style="text-align:center">JS $R1,$R2</td><td style="text-align:center">如果$R1&lt;0，跳转到R2给出的地址</td><td style="text-align:center">35</td></tr><tr><td style="text-align:center">JNS $R1,$R2</td><td style="text-align:center">如果$R1&gt;=0，跳转到R2给出的地址</td><td style="text-align:center">38</td></tr><tr><td style="text-align:center">JG $R1,$R2,$R3</td><td style="text-align:center">如果$R1&gt;$R2，跳转到R3给出的地址</td><td style="text-align:center">37</td></tr><tr><td style="text-align:center">JNG $R1,$R2,$R3</td><td style="text-align:center">如果$R1&lt;=$R2，跳转到R3给出的地址</td><td style="text-align:center">36</td></tr></tbody></table><p>JMP指令的实现很简单,把$IP寄存器的值修改为JMP指令的寄存器操作数里的数值就行了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">JMP:</span><br><span class="line">badAddress(R[RAM[R[$IP]+1]],R[$IP]);</span><br><span class="line">R[$IP]=R[RAM[R[$IP]+1]];</span><br><span class="line">JZ:</span><br><span class="line">if(R[RAM[R[$IP]+1]]==R[RAM[R[$IP]+2]])&#123;</span><br><span class="line">badAddress(R[RAM[R[$IP]+3]],R[$IP]);</span><br><span class="line">R[$IP]=R[RAM[R[$IP]+3]];</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">R[$IP]=R[$IP]+4;</span><br><span class="line">&#125;</span><br><span class="line">······</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;sub-E90代码分析&quot;&gt;&lt;a href=&quot;#sub-E90代码分析&quot; class=&quot;headerlink&quot; title=&quot;sub_E90代码分析&quot;&gt;&lt;/a&gt;sub_E90代码分析&lt;/h2&gt;&lt;p&gt;继续分析接下来的switch分支情况&lt;br&gt;&lt;figure clas
      
    
    </summary>
    
    
      <category term="304反汇编测试" scheme="http://yoursite.com/tags/304%E5%8F%8D%E6%B1%87%E7%BC%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>304Challenge:虚拟机指令执行</title>
    <link href="http://yoursite.com/2019/04/27/304Challenge-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    <id>http://yoursite.com/2019/04/27/304Challenge-虚拟机指令执行/</id>
    <published>2019-04-27T06:48:13.000Z</published>
    <updated>2019-05-24T13:19:32.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="虚拟机指令的执行"><a href="#虚拟机指令的执行" class="headerlink" title="虚拟机指令的执行"></a>虚拟机指令的执行</h2><h3 id="执行流程图"><a href="#执行流程图" class="headerlink" title="执行流程图"></a>执行流程图</h3><p>总结昨天的算法，我画了一个图以更直观的表示出执行过程。<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g2h7d6yv2oj30mk0h574j.jpg" alt></p><h3 id="整数算术运算指令"><a href="#整数算术运算指令" class="headerlink" title="整数算术运算指令"></a>整数算术运算指令</h3><p>今天先来学习下基本的加减乘除指令是怎样执行的?</p><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">含义</th><th style="text-align:center">操作码</th></tr></thead><tbody><tr><td style="text-align:center">ADD $R1,$R2,$R3</td><td style="text-align:center">$R1=$R2+$R3</td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">SUB $R1,$R2,$R3</td><td style="text-align:center">$R1=$R2-R3</td><td style="text-align:center">18</td></tr><tr><td style="text-align:center">MULT $R1,$R2,$R3</td><td style="text-align:center">$R1=$R2*$R3</td><td style="text-align:center">20</td></tr><tr><td style="text-align:center">DIV $R1,$R2,$R3,$R4</td><td style="text-align:center">$R1=$R3/$R4和$R2=$R3%$R4</td><td style="text-align:center">22,24</td></tr></tbody></table><p>下面的代码部分就是这些操作的执行过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ADD:</span><br><span class="line">R[RAM[R[$IP]+1]]=R[RAM[R[$IP]+2]]+R[RAM[R[$IP]+3]];</span><br><span class="line">R[$IP]=R[$IP]+4;</span><br><span class="line">SUB：</span><br><span class="line">R[RAM[R[$IP]+1]]=R[RAM[R[$IP]+2]]-R[RAM[R[$IP]+3]];</span><br><span class="line">R[$IP]=R[$IP]+4;</span><br><span class="line">MULT：</span><br><span class="line">R[RAM[R[$IP]+1]]=R[RAM[R[$IP]+2]] * R[RAM[R[$IP]+3]];</span><br><span class="line">R[$IP]=R[$IP]+4;</span><br></pre></td></tr></table></figure></p><p>加减乘处理过程都比较简单，取出地址的值，进行运算就可。而除这个操作就比较复杂一些，因为在执行指令之前需要检查除数是否为零。如果为0，虚拟机将把”0xFFFFFFFFFFFFFFFFF”放到除法指令的第一个寄存器操作数里去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DIV：</span><br><span class="line">if(R[RAM[R[$IP]+4]]==0)&#123;</span><br><span class="line">ERROR0_LVL2(&quot;Divide by zero!\n&quot;)</span><br><span class="line">R[RAM[R[$IP]+1]]=R[RAM[R[$IP]+2]] =0xFFFFFFFFFFFFFFFFF&quot;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">R[RAM[R[$IP]+1]]=R[RAM[R[$IP]+3]]/R[RAM[R[$IP]+4]];</span><br><span class="line">R[RAM[R[$IP]+2]]=R[RAM[R[$IP]+3]]%R[RAM[R[$IP]+4]];</span><br><span class="line">&#125;</span><br><span class="line">R[$IP]=R[$IP]+5;</span><br></pre></td></tr></table></figure></p><p>通过学习上面通用的算法，回到sub_E90函数中，突然惊奇的发现switch分支的最前面一部分就是整数算术运算指令的处理过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">case 128:</span><br><span class="line">     v11 = *((_WORD *)v1 + (unsigned __int8)v7[2] + 8) + *((_WORD *)v1 + (unsigned __int8)v7[3] + 8);</span><br><span class="line">     goto LABEL_25;</span><br><span class="line">   case 129:</span><br><span class="line">     *((_WORD *)v1 + (unsigned __int8)v7[1] + 8) += __ROL2__(*((_WORD *)v7 + 1), 8);</span><br><span class="line">     return v2;</span><br><span class="line">   case 130:</span><br><span class="line">     v12 = *((_WORD *)v1 + (unsigned __int8)v7[2] + 8) - *((_WORD *)v1 + (unsigned __int8)v7[3] + 8);</span><br><span class="line">     goto LABEL_57;</span><br><span class="line">   case 131:</span><br><span class="line">     *((_WORD *)v1 + (unsigned __int8)v7[1] + 8) -= __ROL2__(*((_WORD *)v7 + 1), 8);</span><br><span class="line">     return v2;</span><br><span class="line">   case 132:</span><br><span class="line">     v11 = *((_WORD *)v1 + (unsigned __int8)v7[2] + 8) * *((_WORD *)v1 + (unsigned __int8)v7[3] + 8);</span><br><span class="line">     goto LABEL_25;</span><br><span class="line">   case 133:</span><br><span class="line">     *((_WORD *)v1 + (unsigned __int8)v7[1] + 8) *= __ROL2__(*((_WORD *)v7 + 1), 8);</span><br><span class="line">     return v2;</span><br><span class="line">   case 134:</span><br><span class="line">     v2 = 0;</span><br><span class="line">     v12 = *((_WORD *)v1 + (unsigned __int8)v7[2] + 8) / *((_WORD *)v1 + (unsigned __int8)v7[3] + 8);</span><br><span class="line">     goto LABEL_57;</span><br><span class="line">   case 135:</span><br><span class="line">     v2 = 0;</span><br><span class="line">     *((_WORD *)v1 + (unsigned __int8)v7[1] + 8) /= __ROL2__(*((_WORD *)v7 + 1), 8);</span><br><span class="line">     return v2;</span><br><span class="line">   case 136:</span><br><span class="line">     v2 = 0;</span><br><span class="line">     *((_WORD *)v1 + (unsigned __int8)v7[1] + 8) = *((_WORD *)v1 + (unsigned __int8)v7[2] + 8)</span><br><span class="line">                                                 % *((_WORD *)v1 + (unsigned __int8)v7[3] + 8);</span><br><span class="line">     return v2;</span><br><span class="line">   case 137:</span><br><span class="line">     v2 = 0;</span><br><span class="line">     *((_WORD *)v1 + (unsigned __int8)v7[1] + 8) %= __ROL2__(*((_WORD *)v7 + 1), 8);</span><br><span class="line">     return v2;</span><br><span class="line">   case 138:</span><br><span class="line">     v11 = *((_WORD *)v1 + (unsigned __int8)v7[2] + 8) &amp; *((_WORD *)v1 + (unsigned __int8)v7[3] + 8);</span><br><span class="line">     goto LABEL_25;</span><br><span class="line">   case 139:</span><br><span class="line">     *((_WORD *)v1 + (unsigned __int8)v7[1] + 8) &amp;= __ROL2__(*((_WORD *)v7 + 1), 8);</span><br><span class="line">     return v2;</span><br><span class="line">   case 140:</span><br><span class="line">     v11 = *((_WORD *)v1 + (unsigned __int8)v7[2] + 8) | *((_WORD *)v1 + (unsigned __int8)v7[3] + 8);</span><br><span class="line">     goto LABEL_25;</span><br><span class="line">   case 141:</span><br><span class="line">     *((_WORD *)v1 + (unsigned __int8)v7[1] + 8) |= __ROL2__(*((_WORD *)v7 + 1), 8);</span><br><span class="line">     return v2;</span><br><span class="line">   case 142:</span><br><span class="line">     v11 = *((_WORD *)v1 + (unsigned __int8)v7[2] + 8) ^ *((_WORD *)v1 + (unsigned __int8)v7[3] + 8);</span><br><span class="line">   case 143:</span><br><span class="line">     *((_WORD *)v1 + (unsigned __int8)v7[1] + 8) ^= __ROL2__(*((_WORD *)v7 + 1), 8);</span><br><span class="line">     return v2;</span><br></pre></td></tr></table></figure></p><p>上面的代码部分涵盖了加、减、乘、除(整除、取余)、与、或、异或操作，其中每两个为一组，区别在于：前一个为三操作数的指令，后一个为两操作数的指令。拿三操作数加法指令为例分析。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">case 128:</span><br><span class="line">       v11 = *((_WORD *)v1 + (unsigned __int8)v7[2] + 8) + *((_WORD *)v1 + (unsigned __int8)v7[3] + 8);</span><br><span class="line">       goto LABEL_25;</span><br><span class="line">   LABEL_25:</span><br><span class="line">       *((_WORD *)v1 + (unsigned __int8)v7[1] + 8) = v11;</span><br><span class="line">       return v2;</span><br></pre></td></tr></table></figure></p><p>这里采用无符号整型数，将寄存器2和寄存器3里的值相加的结果传入v11，跳出到LABEL_25。在LABEL_25处，再将v11传入寄存器1中进行返回，采用了一个间接赋值操作机制。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>myvm中只涉及到整数的算术运算指令，如果遇到浮点型的数，可能就会出错，在这里需要完善一下，加一下格式转换和对小数点的处理等情况。明天将继续分析switch分支的情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;虚拟机指令的执行&quot;&gt;&lt;a href=&quot;#虚拟机指令的执行&quot; class=&quot;headerlink&quot; title=&quot;虚拟机指令的执行&quot;&gt;&lt;/a&gt;虚拟机指令的执行&lt;/h2&gt;&lt;h3 id=&quot;执行流程图&quot;&gt;&lt;a href=&quot;#执行流程图&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="304反汇编测试" scheme="http://yoursite.com/tags/304%E5%8F%8D%E6%B1%87%E7%BC%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>304Challenge:虚拟机的实现</title>
    <link href="http://yoursite.com/2019/04/26/304Challenge-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/04/26/304Challenge-虚拟机的实现/</id>
    <published>2019-04-26T11:59:25.000Z</published>
    <updated>2019-05-24T13:19:39.697Z</updated>
    
    <content type="html"><![CDATA[<p>为了进一步了解虚拟机是如何解释执行任意一段与当前指令集相符的程序，阅读了一篇关于基于寄存器的的虚拟机实现的相关文章。</p><h2 id="虚拟机的设计与实现"><a href="#虚拟机的设计与实现" class="headerlink" title="虚拟机的设计与实现"></a>虚拟机的设计与实现</h2><h3 id="虚拟机原理"><a href="#虚拟机原理" class="headerlink" title="虚拟机原理"></a>虚拟机原理</h3><p>虚拟机用软件模拟指令在硬件机器中执行的全过程，即先从磁盘中读取字节码文件 ，存储到虚拟机开辟的内存段中，再将指令加载到虚拟机寄存器并予以执行。它并不是指某个特定的软件 ，而是一整套完整的规范，可以用不同的程序设计语言在不同的硬件平台上实现。不论是硬件机器还是虚拟机系统 ，只要遵循相同的规范，即可运行遵循该规范的可执行代码。</p><h3 id="两种处理器引擎"><a href="#两种处理器引擎" class="headerlink" title="两种处理器引擎"></a>两种处理器引擎</h3><p>Stack-Based虚拟机在运行时对系统资源的消耗要远小于Register-Based虚拟机 ，但堆栈将会延伸到内存 ，后者的计算处理则全部在芯片内部的寄存器上完成，因此后者的处理速度要远远高于前者。</p><h3 id="虚拟机的工作流程"><a href="#虚拟机的工作流程" class="headerlink" title="虚拟机的工作流程"></a>虚拟机的工作流程</h3><p>1.启动虚拟机，并处理命令行输入<br>2.初始化虚拟机运行环境<br>3.调入并加载文件<br>4.格式化内存存储方式<br>5.执行指令<br>其中虚拟机的初始化和执行字节码阶段是整个程序运行的核心</p><h4 id="初始化虚拟机"><a href="#初始化虚拟机" class="headerlink" title="初始化虚拟机"></a>初始化虚拟机</h4><p>通过输入命令行，获取字节码文件的信息，并传入处理函数。在myvm中其实就是将文件送入sub_CE0()中，将字节码字段加载到 内存空间的正文段。为了清楚的描述sub_CE0()的功能，将它的算法提炼出来如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">if(文件大小为零或文件打开错误)</span><br><span class="line">&#123;记录并打印错误，并直接返回 &#125;</span><br><span class="line">if(正文段、数据段和堆栈段的长度之和 宿主机的可用内存)</span><br><span class="line">&#123;记录并打印错误，并直接返回 &#125;</span><br><span class="line">分配内存 R= malloc(正文段、数据段和堆栈段的长度之和)；</span><br><span class="line">初始化段寄存器：</span><br><span class="line">RICS]指向正文段末尾</span><br><span class="line">R[DS]指向数据段首</span><br><span class="line">R[ES]指向数据段末尾</span><br><span class="line">R[SSI指向堆栈段首</span><br><span class="line">R[TOP]指向堆栈段的末尾 ，即所开辟内存空问的末尾</span><br><span class="line">初始化指针寄存器 ：</span><br><span class="line">R[IP]指向正文段首，即内存地址为O处</span><br><span class="line">R[SP]指向所开辟内存空间的末尾</span><br><span class="line">重新返回字节码文件的字节码部分，调用fseek()定位字节码部分的位置；</span><br><span class="line">读取字节码部分，并将其加载入所开辟的内存正文段中。</span><br></pre></td></tr></table></figure></p><h4 id="执行字节码"><a href="#执行字节码" class="headerlink" title="执行字节码"></a>执行字节码</h4><p>加载好字节码内容后，就该将这些字节码翻译执行了。把这些字节码送入指令执行引擎函数sub_E90中，将字节码指令从虚拟地址0处开始逐条执行，当遇到HALT指令或发生错误时停止。参照基于寄存器的处理器的设计方法 ，此阶段指令执行过程的算法如下(其中，R[IP]表示指令指针寄存器IP的值 ；RAM[R[IP]]表示 内存地址为R[IP]处的指令或数值)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">while(内存地址为r[iP]不等于中止指令HALT)&#123;</span><br><span class="line">switch(内存地址为r[ip]的指令)&#123;</span><br><span class="line">case MOV：&#123;···；&#125;break；</span><br><span class="line">······各种指令的具体执行：</span><br><span class="line">default：&#123;ERROR；&#125;break；</span><br><span class="line">&#125;</span><br><span class="line">将指令指针IP指向下一条指令；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实准确来讲myvm中sub_E90函数执行的是中间switch那段，用于识别各种机器指令，并执行。<br>机器指令按照操作数的不同来分，包括双操作数指令(OP DEST，SRC)、单操作数指令(OPDEST)、无操作数指令(op)等3种。由于操作数的不同直接关系到指令指针IP的变化不同，因此R[IP]值的变化将因具体指令的操作数不同而异。下面通过 LAI R1，R2，qword指令来解释具体的指令执行过程 。<br>指令功能：将基地址(reg2)和地址偏移量(8 bytes常量)相加得到的结果存入目的寄存器中<br>指令流程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">寄存器1=寄存器2的值+8字节常量</span><br><span class="line">R[下标]=R[下标+1]+(signed_int64)*(signed_int64 *)常量地址</span><br><span class="line">R[下标]=R[下标+1]+(signed_int64)*(signed_int64 *)&amp; RAM[下标+2]</span><br><span class="line">下标=RAM[reg1]</span><br><span class="line">R[RAM[R[IP]+1]]=R[RAM[R[IP]+2]]+(signed_int64)*(signed_int64 *)&amp; RAM[R[IP]+3]</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过今天的学习验证了之前代码的分析，也初步明确sub_E90中switch分支的结构，下一步应该对switch每一条语句进行分析，识别出每一个分支具体实现了哪条指令。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了进一步了解虚拟机是如何解释执行任意一段与当前指令集相符的程序，阅读了一篇关于基于寄存器的的虚拟机实现的相关文章。&lt;/p&gt;
&lt;h2 id=&quot;虚拟机的设计与实现&quot;&gt;&lt;a href=&quot;#虚拟机的设计与实现&quot; class=&quot;headerlink&quot; title=&quot;虚拟机的设计与实
      
    
    </summary>
    
    
      <category term="304反汇编测试" scheme="http://yoursite.com/tags/304%E5%8F%8D%E6%B1%87%E7%BC%96%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
