<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tan&#39;s Blog</title>
  
  <subtitle>Tan&#39;s Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-11T14:01:32.692Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Tan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>windows操作系统基础</title>
    <link href="http://yoursite.com/2019/06/11/windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/06/11/windows操作系统基础/</id>
    <published>2019-06-11T13:24:30.000Z</published>
    <updated>2019-06-11T14:01:32.692Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Windows操作系统基础"><a href="#Windows操作系统基础" class="headerlink" title="Windows操作系统基础"></a>Windows操作系统基础</h2><h3 id="PE文件结构"><a href="#PE文件结构" class="headerlink" title="PE文件结构"></a>PE文件结构</h3><p>PE文件的全称是Portable Executable，意为可移植的可执行的文件，常见的EXE、DLL、OCX、SYS、COM都是PE文件，PE文件是微软Windows操作系统上的程序文件（可能是间接被执行，如DLL）。PE文件包括PE文件头和PE数据区，PE文件头包括DOS头和PE头，PE数据区包括区块表和区块，区块中包括导入表、导出表等部分。</p><h3 id="进程和线程管理"><a href="#进程和线程管理" class="headerlink" title="进程和线程管理"></a>进程和线程管理</h3><p>1、线程，有时被称为轻量级进程，是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针，寄存器集合和堆栈组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。<br>2、进程定义了一个执行环境，包括它自己私有的地址空间、一个句柄表，以及一个安全环境；线程则是一个控制流，有自己的调用栈，记录了执行的历史。每个进程都包含一个或多个线程，当进程被初始化创建时系统为该进程创建第一个线程；当最后一个线程结束时，进程也随之结束。<br>进程中的线程既可以在用户模式下运行，也可以在内核模式下运行。如果一个进程运行在用户模式下，那么它就只能访问进程地址空间；如果运行在内核模式下，那么它将可以访问这个地址空间。</p><h4 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h4><p>应用程序在操作系统提供的单个控制流的基础上，通过在有些控制点（比如系统调用）上分离出一些虚拟的控制流，从而模拟多个控制流的行为。由于应用程序对指令流的控制能力相对较弱，所以，用户级线程之间的切换往往受线程本身行为以及线程控制点选择的影响，线程是否能够公平地获得处理器时间取决于这些线程的代码特征。而且，支持用户级线程的应用程序代码很难做到跨平台移植，以及对于多线程模型的透明。用户级线程模型的优势：<br>（1）线程切换效率高，因为它不涉及系统内核模式和用户模式之间的切换；<br>（2）另外一个好处是应用程序可以采用适合自己特点的线程选择算法，可以根据应用程序的逻辑来定义线程的优先级，当线程数量很大时。但是，相对的会增加应用程序代码的复杂度。</p><h4 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h4><p>指操作系统提供的线程语义，由于操作系统对指令流有完全的控制能力，甚至可以通过硬件终端来强迫一个进程或是线程暂停执行，以便把处理器时间移交给其他的进程或是线程，所以，内核级线程有可能应用各种算法来分配处理器时间。线程可以有优先级，高优先级的线程被优化执行，他们可以抢占正在执行的低优先级线程。在支持线程语义的操作系统中，处理器的时间通常是按照线程而非进城来分配的，因此，系统有必要维护一个全局的线程表，在线程表中记录每个线程的寄存器、状态以及其他的一些信息。然后，系统在适当的时候挂起一个正在执行的线程，选择一个新的线程在当前处理器上继续执行。<br>内核级线程的好处：<br>应用程序无需考虑是够要在适当的时候把控制权交给其他的线程，不比担心自己霸占处理器而导致其他线程得不到处理器时间。因而应用程序只要按照正常的指令来实现自己的逻辑就可以了，内核会妥善处理好线程之间的共享处理器的资源分配问题。但是这样带来的代价便是需要在用户模式和内核模式下进行切换：从用户模式切换到内核模式，再从内核模式切换到用户模式。在Intel的处理器上可能需要几百上千和处理器指令周期。</p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>Windows系统使用内存管理器对内存进行管理，主要负责两个任务：将进程的虚拟地址空间转译到物理内存，在内存不足时将数据换页到磁盘。</p><h3 id="对象与句柄管理"><a href="#对象与句柄管理" class="headerlink" title="对象与句柄管理"></a>对象与句柄管理</h3><p>Windows对象管理是WindowsExecutive的一个子系统实现，用于管理Windows资源。资源包括物理设备、文件、文件目录、注册表条目、正在运行的进程等等。所有子系统访问资源都必须通过对象管理子系统。<br>在程序设计中，句柄是一种特殊的智能指针 。当一个应用程序要引用其他系统（如数据库、操作系统）所管理的内存块或对象时，就要使用句柄。<br>句柄与普通指针的区别在于，指针包含的是引用对象的内存地址，而句柄则是由系统所管理的引用标识，该标识可以被系统重新定位到一个内存地址上。这种间接访问对象的模式增强了系统对引用对象的控制。</p><h3 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h3><p>文件系统是操作系统用于明确存储设备或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。操作系统中负责管理和存储文件信息的软件机构称为文件管理系统，简称文件系统。文件系统由三部分组成：文件系统的接口，对对象操纵和管理的软件集合，对象及属性。从系统角度来看，文件系统是对文件存储设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。具体地说，它负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，当用户不再使用时撤销文件等。<br>Windows操作系统包含对CDFS、UDF、FAT12、FAT16、FAT32、NTFS这些文件系统格式的支持，不同的格式适用于不同的特定环境。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Windows操作系统基础&quot;&gt;&lt;a href=&quot;#Windows操作系统基础&quot; class=&quot;headerlink&quot; title=&quot;Windows操作系统基础&quot;&gt;&lt;/a&gt;Windows操作系统基础&lt;/h2&gt;&lt;h3 id=&quot;PE文件结构&quot;&gt;&lt;a href=&quot;#PE文
      
    
    </summary>
    
    
      <category term="软件安全分析与应用" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>处理器架构和反汇编对抗技术</title>
    <link href="http://yoursite.com/2019/06/09/%E5%A4%84%E7%90%86%E5%99%A8%E6%9E%B6%E6%9E%84%E5%92%8C%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    <id>http://yoursite.com/2019/06/09/处理器架构和反汇编/</id>
    <published>2019-06-09T09:25:37.000Z</published>
    <updated>2019-06-09T13:17:51.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="处理器的硬件架构"><a href="#处理器的硬件架构" class="headerlink" title="处理器的硬件架构"></a>处理器的硬件架构</h2><h3 id="CPU结构介绍"><a href="#CPU结构介绍" class="headerlink" title="CPU结构介绍"></a>CPU结构介绍</h3><p>处理器一般指中央处理器，中央处理器是一块超大规模的集成电路，是一台计算机的运算核心和控制核心。它的功能主要是解释计算机指令以及处理计算机软件中的数据。<br>CPU的根本任务就是执行指令，对计算机来说最终都是一串由“0”和“1”组成的序列。CPU从逻辑上可以划分成3个模块，分别是控制单元、运算单元和存储单元，这三部分由CPU内部总线连接起来。如下所示:<br><img src="https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=3be320705ee736d14c1e845afa3924a7/9f510fb30f2442a75ade9309db43ad4bd013024d.jpg" alt></p><h3 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h3><p>保护模式与实模式相对应。在80286以前，CPU只有实时模式，地址总线有20位，而内存地址是16位，也就是最多能够访问2^20=1M的内存空间。在80286及以后，内存地址改为16位或32位，至少可以访问到2^32=4G的内存空间。但为了保证后续的CPU能够运行旧的CPU，只能保持向下兼容。因此，80286及以后的CPU首先进入实模式，然后通过切换机制再进入到保护模式。<br>保护模式与实模式相比，主要是两个差别：一是提供了段间的保护机制，防止程序间胡乱访问地址带来的问题，二是访问的内存空间变大。</p><h3 id="特权级"><a href="#特权级" class="headerlink" title="特权级"></a>特权级</h3><p>特权级也称为用户态。它是一种机制来保护数据和阻止恶意行为（确保计算机安全）。电脑操作系统提供不同权限访问级别的资源。特权级分为4级，特权级0、1、2、3。<br>在windows中只使用特权级0和特权级3。特权最高的一般是特权级0，可以直接操作硬件，如CPU和内存。一般操作系统和驱动运行在此级别下。特权级3是给一般的程序使用的，可以调用基本的CPU指令。在特权级三无法调用特权级0的指令，如果调用则显示为非法指令。<br>引用特权级的概念是为了保护计算机，一些危险指令只有操作系统可以执行，防止普通程序滥用其他程序的资源。如间谍软件要想开启摄像头就必须向特权级0的驱动程序请求开启，否则就不允许。</p><h3 id="中断和异常处理"><a href="#中断和异常处理" class="headerlink" title="中断和异常处理"></a>中断和异常处理</h3><p>中断是指CPU对系统发生某事件时的这样一种响应：CPU暂停正在执行的程序，在保留现场后自动地转去执行该事件的中断处理程序；执行完后，再返回到原程序的断点处继续执行。错误中断处理是指处理机调用相关的中断处理程序处理当前错误。计算机中错误可以分为软件错误和硬件错误，如程序出错(非法指令、地址越界)、电源故障等。</p><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>程序调试是软件开发过程中进行排错和查错的过程，需要CPU架构的支持。IA-32架构的CPU中，标志位寄存器EFLAGS中的IF、TF标志用于调试模式的开启，将TF位置1使CPU处于单步执行状态，同时需要将IF位置1，开启CPU中断响应。</p><h3 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h3><p>虚拟化技术与多任务以及超线程技术是完全不同的。多任务是指在一个操作系统中多个程序同时一起运行，而在虚拟化技术中，则可以同时运行多个操作系统，而且每一个操作系统中都有多个程序运行，每一个操作系统都运行在一个虚拟的CPU或者是虚拟主机上；而超线程技术只是单CPU模拟双CPU来平衡程序运行性能，这两个模拟出来的CPU是不能分离的，只能协同工作。</p><h2 id="反汇编的对抗技术"><a href="#反汇编的对抗技术" class="headerlink" title="反汇编的对抗技术"></a>反汇编的对抗技术</h2><h3 id="代码混淆"><a href="#代码混淆" class="headerlink" title="代码混淆"></a>代码混淆</h3><p>代码混淆是将计算机程序的代码，转换成一种功能上等价，但是难于阅读和理解的形式的行为。代码混淆可以用于程序源代码，也可以用于程序编译而成的中间代码。执行代码混淆的程序被称作代码混淆器。目前已经存在许多种功能各异的代码混淆器。<br>将代码中的各种元素，如变量，函数，类的名字改写成无意义的名字。比如改写成单个字母，或是简短的无意义字母组合，甚至改写成“__”这样的符号，使得阅读的人无法根据名字猜测其用途。重写代码中的部分逻辑，将其变成功能上等价，但是更难理解的形式。比如将for循环改写成while循环，将循环改写成递归，精简中间变量，等等。打乱代码的格式。比如删除空格，将多行代码挤到一行中，或者将一行代码断成多行等等。</p><h3 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h3><p>反调试技术，恶意代码用它识别是否被调试，或者让调试器失效。恶意代码编写者意识到分析人员经常使用调试器来观察恶意代码的操作，因此他们使用反调试技术尽可能地延长恶意代码的分析时间。为了阻止调试器的分析，当恶意代码意识到自己被调试时，它们可能改变正常的执行路径或者修改自身程序让自己崩溃，从而增加调试时间和复杂度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;处理器的硬件架构&quot;&gt;&lt;a href=&quot;#处理器的硬件架构&quot; class=&quot;headerlink&quot; title=&quot;处理器的硬件架构&quot;&gt;&lt;/a&gt;处理器的硬件架构&lt;/h2&gt;&lt;h3 id=&quot;CPU结构介绍&quot;&gt;&lt;a href=&quot;#CPU结构介绍&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="软件安全分析与应用" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件安全分析的主要方法</title>
    <link href="http://yoursite.com/2019/06/06/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/06/06/软件安全分析的主要方法/</id>
    <published>2019-06-06T13:10:38.000Z</published>
    <updated>2019-06-06T13:54:11.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主要方法与技术"><a href="#主要方法与技术" class="headerlink" title="主要方法与技术"></a>主要方法与技术</h2><p>软件逆向分析并不是一种单项技术，其涉及的技术和方法很多。按照分析方式的不同，可以将软件逆向分析分为静态和动态两大类。静态分析主要是直接对软件的可执行代码进行分析；而动态分析是通过直接运行软件，然后监测软件运行过程，实施分析。在实际分析过程中，主流的思路是以动态分析为主，一方面利用模糊测试等技术构造执行的不同路径，另一方面也利用静态分析手段弥补动态分析过程中的不足，优化和提升动态分析的能力。</p><h3 id="反汇编与反编译"><a href="#反汇编与反编译" class="headerlink" title="反汇编与反编译"></a>反汇编与反编译</h3><p>反汇编与反编译是软件逆向分析的第一步，将完全不可读的二进制可执行程序转变为用户基本可读、功能等价的汇编代码或其他高级语言代码。</p><h3 id="程序调试"><a href="#程序调试" class="headerlink" title="程序调试"></a>程序调试</h3><p>程序调试是通过实际运行软件，利用断点、单步执行等方式对软件执行过程进行细粒度分析的过程。一般性的应用软件调试借助于WinDbg等就可实现，对于操作系统驱动程序等内核代码的调试较为复杂，需要借助于SoftICE或者VMware+WinDbg等调试工具。<br>与传统的静态分析方法相比，程序调试的优点在于它可避免用户对指令的复杂推理分析过程，可以直接对每条指令的执行结果进行分析。</p><h3 id="程序切片"><a href="#程序切片" class="headerlink" title="程序切片"></a>程序切片</h3><p>程序切片通过分析程序代码之间的依赖关系来分析指令的相关性，从而帮助用户提取其所感兴趣的代码片段。</p><h3 id="污点传播分析"><a href="#污点传播分析" class="headerlink" title="污点传播分析"></a>污点传播分析</h3><p>污点传播分析将所感兴趣的数据做标记，然后通过分析对该污点数据的处理过程，根据每条指令的污点传播规则，分析数据的传递关系。</p><h3 id="符号执行"><a href="#符号执行" class="headerlink" title="符号执行"></a>符号执行</h3><p>符号执行的基本思想是用符号变量作为输入参数，对程序进行模拟执行，然后对程序的执行路径进行分析，并提取路径中的约束条件，通过对约束进行求解实现对程序安全性及路径可达性等分析。</p><h3 id="模糊测试"><a href="#模糊测试" class="headerlink" title="模糊测试"></a>模糊测试</h3><p>模糊测试的基本思想是通过构造各种不同的输入参数，尽可能触发执行软件的各种路径，通过对执行结果的监测来实现相关的分析或检测目标。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="恶意软件分析"><a href="#恶意软件分析" class="headerlink" title="恶意软件分析"></a>恶意软件分析</h3><p>恶意软件的分析过程是不可能依赖源代码的，因此，对恶意软件的分析只能依赖于软件逆向分析。</p><h3 id="网络协议逆向分析"><a href="#网络协议逆向分析" class="headerlink" title="网络协议逆向分析"></a>网络协议逆向分析</h3><p>当前网络空间中的绝大多数应用都要依赖于网络和网络协议，通过网络协议逆向分析可以提取出网络协议中数据包格式、关键字、协议状态机等信息，从而对僵尸网络设计抑制机制。</p><h3 id="软件漏洞分析与利用"><a href="#软件漏洞分析与利用" class="headerlink" title="软件漏洞分析与利用"></a>软件漏洞分析与利用</h3><p>对于软件漏洞的发现方式有多种，比如模糊测试、预先筛选可疑代码等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;主要方法与技术&quot;&gt;&lt;a href=&quot;#主要方法与技术&quot; class=&quot;headerlink&quot; title=&quot;主要方法与技术&quot;&gt;&lt;/a&gt;主要方法与技术&lt;/h2&gt;&lt;p&gt;软件逆向分析并不是一种单项技术，其涉及的技术和方法很多。按照分析方式的不同，可以将软件逆向分析分为静
      
    
    </summary>
    
    
      <category term="软件安全分析与应用" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>软件安全分析概论</title>
    <link href="http://yoursite.com/2019/06/05/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E6%A6%82%E8%AE%BA/"/>
    <id>http://yoursite.com/2019/06/05/软件安全分析概论/</id>
    <published>2019-06-05T12:29:31.000Z</published>
    <updated>2019-06-05T13:04:20.057Z</updated>
    
    <content type="html"><![CDATA[<p>随着技术的发展，软件的应用越来越广泛，软件的功能也越来越复杂，而市场竞争等因素造成软件的开发周期越来越短，问题也将越来越多。如何对软件产品进行安全性分析，发现相关问题，剖析安全问题机理，进而研发设计相应的防御手段，是软件安全性分析的主要目标。</p><h2 id="典型的安全问题"><a href="#典型的安全问题" class="headerlink" title="典型的安全问题"></a>典型的安全问题</h2><p>当前软件安全问题可粗略分为3类</p><h3 id="恶意软件"><a href="#恶意软件" class="headerlink" title="恶意软件"></a>恶意软件</h3><p>恶意软件就是包含恶意功能的软件，随着信息技术的不断发展，恶意软件也在不断地升级，从最早的单机传播到网络传播再到协同攻击阶段，危害的程度与范围越来越大，而且极其隐蔽很难被发现。<br>近些年曝光的恶意软件，越来越多的是有组织研发，采用高技术手段，具有很强的渗透能力和生存能力，比如说RSA公司遭受SecurID窃取攻击和Hacking Team遭受APT攻击，这些都是非常闻名的公司，却依然遭到了攻击，并造成了严重的损失，所以说处理软件安全问题迫在眉睫。</p><h3 id="软件漏洞"><a href="#软件漏洞" class="headerlink" title="软件漏洞"></a>软件漏洞</h3><p>软件漏洞是指由于程序设计实现错误造成的软件问题，攻击者利用软件漏洞往往可以造成程序崩溃，获取敏感数据或执行任意代码。<br>经典的JPEG漏洞就是利用数据复制时出现的越界读写，经过一系列精心的构造，诱导程序执行shellcode。</p><h3 id="软件后门"><a href="#软件后门" class="headerlink" title="软件后门"></a>软件后门</h3><p>软件后门是由软件开发人员有意设计，刻意对用户隐瞒一些功能，往往这些功能用于软件产品应用之后的一些特殊目的。一些软件开发人员将软件后门设计为软件漏洞的形式，采取这种方法更难被发现，容易操作执行并且还很难被取证。</p><h2 id="软件安全性分析的目标"><a href="#软件安全性分析的目标" class="headerlink" title="软件安全性分析的目标"></a>软件安全性分析的目标</h2><p>软件安全性分析一般要回答以下三方面的问题<br>(1)存在问题<br>目标软件中是否存在恶意功能，是否存在漏洞或者后门。<br>(2)机理问题<br>确定问题存在后，进一步分析其具体是如何实现的或者是什么原因造成的。<br>(3)对策问题<br>根据相关机理分析结果，提出相应的防御对策。<br>现在许多软件常常都无法获得源代码，而在这种情况下进行软件的逆向分析就有几大难点：对于指令代码的理解，关联关系的抽取和复杂逻辑的解析等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着技术的发展，软件的应用越来越广泛，软件的功能也越来越复杂，而市场竞争等因素造成软件的开发周期越来越短，问题也将越来越多。如何对软件产品进行安全性分析，发现相关问题，剖析安全问题机理，进而研发设计相应的防御手段，是软件安全性分析的主要目标。&lt;/p&gt;
&lt;h2 id=&quot;典型的
      
    
    </summary>
    
    
      <category term="软件安全分析与应用" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 套接字接口(续)</title>
    <link href="http://yoursite.com/2019/06/02/CSAPP-%E5%A5%97%E6%8E%A5%E5%AD%97%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2019/06/02/CSAPP-套接字接口/</id>
    <published>2019-06-02T07:28:21.000Z</published>
    <updated>2019-06-02T07:42:08.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="套接字接口"><a href="#套接字接口" class="headerlink" title="套接字接口"></a>套接字接口</h2><h3 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h3><p>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就向TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。</p><pre><code>#include&lt;sys/socket.h&gt;int accept(int listenfd,struct sockaddr *addr,int *addrlen);//返回：成功为非负连接描述符，出错-1</code></pre><p>第一个参数为服务器的socket描述字<br>第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址<br>第三个参数为协议地址的长度<br>成功后返回一个已连接描述符，用来利用Unix I/O函数与客户端通信</p><h3 id="主机和服务的转换"><a href="#主机和服务的转换" class="headerlink" title="主机和服务的转换"></a>主机和服务的转换</h3><h4 id="getaddrinfo函数"><a href="#getaddrinfo函数" class="headerlink" title="getaddrinfo函数"></a>getaddrinfo函数</h4><p>getaddrinfo函数将主机名、主机地址、服务名和端口号得字符串表示转化成套接字地址结构，这个函数可重入的，适用于任何协议。</p><pre><code>#include&lt;sys/types.h&gt;#include&lt;sys/socket.h&gt;#include&lt;netdb.h&gt;int getaddrinfo(const char *host,const char *service,const struct addrinfo *hints,struct addrinfo **result);//返回：成功0，出错为非零得错误代码void freeaddrinfo(struct addrinfo *result);//释放链表，返回无const char *gai_strerror(int errcode);//返回错误信息</code></pre><p>getaddrinfo返回的数据结构：</p><pre><code>struct addrinfo{    int ai_flags;    int ai_family;    int ai_socktype;    int ai_protocol;    char *ai_canonname;    size_t ai_addrlen;    struct sockaddr *ai_addr;    struct addrinfo *ai_next;}</code></pre><p>为了避免内存泄漏，应用程序必须在最后调用freeaddrinfo，释放该链表，如果getaddrinfo返回非零的错误代码，应用程序可以调用gai_strerror,该代码转换成消息字符串。<br>host:一个主机名或者地址串(IPv4的点分十进制串或者IPv6的16进制串)<br>service：服务名可以是十进制的端口号，也可以是已定义的服务名称，如ftp、http等<br>hints：可以是一个空指针，也可以是一个指向某个addrinfo结构体的指针，调用者在这个结构中填入关于期望返回的信息类型的暗示。举例来说：如果指定的服务既支持TCP也支持UDP，那么调用者可以把hints结构中的ai_socktype成员设置成SOCK_DGRAM使得返回的仅仅是适用于数据报套接口的信息。<br>result：本函数通过result指针参数返回一个指向addrinfo结构体链表的指针。</p><h4 id="getnameinfo-函数"><a href="#getnameinfo-函数" class="headerlink" title="getnameinfo 函数"></a>getnameinfo 函数</h4><p>将一个套接字地址结构转换成相应得主机和服务名字符串。</p><pre><code>#include&lt;sys/socket.h&gt;#include&lt;netdb.h&gt;int getnameinfo(const struct sockaddr *sa,socklen_t salen,char *host,size_t hostlen,char *service,size_t servlen,int flags);//返回：成功0，出错为非零错误代码</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;套接字接口&quot;&gt;&lt;a href=&quot;#套接字接口&quot; class=&quot;headerlink&quot; title=&quot;套接字接口&quot;&gt;&lt;/a&gt;套接字接口&lt;/h2&gt;&lt;h3 id=&quot;accept函数&quot;&gt;&lt;a href=&quot;#accept函数&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP 网络编程</title>
    <link href="http://yoursite.com/2019/05/30/CSAPP-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/05/30/CSAPP-网络编程/</id>
    <published>2019-05-30T12:15:16.000Z</published>
    <updated>2019-05-30T12:41:08.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CS编程模型"><a href="#CS编程模型" class="headerlink" title="CS编程模型"></a>CS编程模型</h2><p>每个网络应用都是基于客户端-服务器模型的。<br>客户端-服务器模型中的基本操作是事务。一个客户端-服务器事务由以下四步组成：<br>1.当一个客户端需要服务时，它向服务器发送一个请求，发起一个事务。<br>2.服务器收到请求后，解释它，并以适当的方式操作它的资源。<br>3.服务器给客户端发送一个响应，并等待下一个请求。<br>4.客户端收到响应并处理它</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>客户端和服务器通常运行在不同的主机上，并通过计算机网络的硬件和软件资源来通信。<br>对主机而言，网络是一种I/O设备，是数据源和数据接收方<br>从物理上而言，网络是一个按照地理远近组成的层次系统。最低层是LAN（局域网），最流行的局域网技术是以太网。</p><h2 id="套接字接口"><a href="#套接字接口" class="headerlink" title="套接字接口"></a>套接字接口</h2><p>套接字接口是一组函数，它们和Unix I/O函数结合起来，用以创建网络应用。</p><h3 id="套接字地址结构"><a href="#套接字地址结构" class="headerlink" title="套接字地址结构"></a>套接字地址结构</h3><p>从Linux内核看，一个套接字就是通信的一个端点，从Linux程序看，套接字就是一个有相应描述符的打开文件.<br>因特网的套接字地址存放在sockaddr_in的16字节结构中，对于IPV4来说，sin_family为AF_INET,sin_port为一个16位的端口号，sin_addr为一个32位的IP地址。</p><h3 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h3><p>客户端和服务器使用socket函数来创建一个套接字描述符</p><pre><code>#include&lt;sys/types.h&gt;#include&lt;sys/socket.h&gt;int socket(int domain,int type,int protocol);//返回：成功返回非负描述符，出错-1</code></pre><p><strong>domain：</strong>即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。<br><strong>type：</strong>指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等。<br>（1）SOCK_STREAM（流套接字） 提供面向连接、可靠的数据传输服务。使用了TCP协议<br>（2）SOCK_DGRAM（数据报套接字）提供无连接的服务，使用UDP协议<br>（3）SOCK_RAW(原始套接字) 提供单一的网络访问，这个socket类型使用ICMP公共协议<br><strong>protocol：</strong>故名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议<br>注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。<br>例：对于ipv4创建socket,其中使用tcp协议</p><pre><code>sock = socket(AF_INET,SOCK_STREAM,0);</code></pre><h3 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h3><p>客户端通过调用connect函数建立和服务器的连接</p><pre><code>#include&lt;sys/socket.h&gt;int connect(int sockfd,const struct sockaddr *addr,socklen_t addrlen);//返回：成功则为0，出错-1</code></pre><p>第一个参数即为客户端的socket描述字<br>第二参数为服务器的socket地址<br>第三个参数为socket地址的长度，一般为sizeof(sockaddr_in)。<br>connect函数回阻塞，一直到连接成功建立或发生错误。</p><h3 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h3><p>bind函数告诉内核将addr中的服务器套接字地址和套接字描述符sockfd联系起来</p><pre><code>#include&lt;sys/socket.h&gt;int bind(int sockfd,const struct sockaddr *addr,socklen_t addrlen);//返回：成功0，出错-1</code></pre><p>第一个参数sockfd是由socket()调用返回的套接口文件描述符。<br>第二个参数addr是指向数据结构sockaddr的指针。数据结构sockaddr中包括了关于你的地址、端口和IP地址的信息。<br>第三个参数addrlen可以设置成sizeof(struct sockaddr_in)。</p><h3 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h3><p>listen函数将sockfd从一个主动套接字转化为一个监听套接字。<br>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。</p><pre><code>#include&lt;sys/socket.h&gt;int listen(int sockfd,int backlog);//成功0，出错-1</code></pre><p>第一个参数即为要监听的socket描述符,第二个参数为相应socket可以排队的最大连接个数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CS编程模型&quot;&gt;&lt;a href=&quot;#CS编程模型&quot; class=&quot;headerlink&quot; title=&quot;CS编程模型&quot;&gt;&lt;/a&gt;CS编程模型&lt;/h2&gt;&lt;p&gt;每个网络应用都是基于客户端-服务器模型的。&lt;br&gt;客户端-服务器模型中的基本操作是事务。一个客户端-服务器事
      
    
    </summary>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>搭建一个网站</title>
    <link href="http://yoursite.com/2019/05/28/%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99/"/>
    <id>http://yoursite.com/2019/05/28/搭建一个网站/</id>
    <published>2019-05-28T07:35:08.000Z</published>
    <updated>2019-05-28T09:24:03.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>一台云虚拟主机、域名、网站模版</p><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><h3 id="购买主机"><a href="#购买主机" class="headerlink" title="购买主机"></a>购买主机</h3><p>购买一台网络云虚拟主机，可以考虑阿里云、腾讯云、百度云等，我选择购买了阿里云虚拟主机，接下来就以阿里云虚拟主机为例。<br>打开阿里云官网，点产品-&gt;企业应用-&gt;云虚拟主机，我选择的这一款是基础款，三年597，适合个人入门建站。<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g3h30cq1gyj30e20pomz8.jpg" alt><br>选择购买后，要选择机房，不同的机房没什么太大区别，主要选离自己近的。还有一个要选择好操作系统，这个根据自己的需求，后期也可以进行更换。网站开发语言为 PHP、HTML、WAP，数据库为MySQL、SQLite请选择Linux操作系统；网站开发语言为 ASP、.NET、HTML，数据库为 ACCESS、SQL Server 请选择 Windows 系统。</p><h3 id="查看主机信息，重置主机相关密码"><a href="#查看主机信息，重置主机相关密码" class="headerlink" title="查看主机信息，重置主机相关密码"></a>查看主机信息，重置主机相关密码</h3><p>登录<a href="https://account.aliyun.com/login/login.htm?oauth_callback=http%3A%2F%2Fnetcn.console.aliyun.com%2Fcore%2Fhost%2Flist2%3Fspm%3Da2c4g.11186623.2.18.1e4bf23fNrBc4k" target="_blank" rel="noopener">云虚拟主机管理页面</a>。单击操作栏中管理，进入主机管理平台。在主机管理平台首页，您可查看网页信息和主机账号信息，且可重置主机的管理控制台密码、FTP 登录密码、数据库管理密码。<br><img src="http://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/pic/64847/cn_zh/1515050753561/1.jpg" alt><br><img src="http://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/pic/64847/cn_zh/1515050775374/2.jpg" alt><br><strong>临时域名：</strong>用于网页调试。<br><strong>主机管理控制台用户名和密码：</strong>用于备案产品验证。<br><strong>FTP 登录用户名、密码和 FTP 登录主机地址：</strong>用于上传网站程序。<br><strong>数据库信息：</strong>用于数据库管理和使用。</p><h3 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h3><p>主机自带的临时域名仅作为调试网站使用，想要网站上线还需要购买一个域名，直接在阿里云域名注册（万网） 页面注册域名。去控制台域名管理-&gt;域名绑定，绑定自己的刚注册的域名。</p><h3 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h3><p>通过域名访问IP，我们还需要解析域名，点击域名后的解析录入信息，大约十分钟后，测试是否解析成功。打开cmd，用ping命令连接自己的域名，若域名后出现IP地址，则说明解析成功。</p><h3 id="上传网站程序"><a href="#上传网站程序" class="headerlink" title="上传网站程序"></a>上传网站程序</h3><p>直接使用ftp协议上传文件，对于windows系统直接输入ftp://主机ip地址，并回车，输入之前设置过的用户名和密码，就可以直接看到ftp上的所有文件了。因为我使用的主机是Linux系统，需要把模版文件上传到/htdocs目录下，windows系统直接上传到根目录下即可。<br>因为上传的文件很大，我直接放了个压缩包上去，之后登陆主机管理控制台，文件管理 -&gt; 文件解压缩，解压这个包，这样比较快一些。</p><h3 id="数据库的导入"><a href="#数据库的导入" class="headerlink" title="数据库的导入"></a>数据库的导入</h3><p>我使用的网页模版是织梦模版，按照它的方法还需要安装，前方指路右拐<a href="http://www.dedeyuan.com/cms/dedejc/13.html" target="_blank" rel="noopener">安装方法</a>，按照这个方法把数据还原，重新生成一下网页，就可以了。</p><h3 id="网站的安全防护"><a href="#网站的安全防护" class="headerlink" title="网站的安全防护"></a>网站的安全防护</h3><p>因为织梦的网页模版的后台都是在dede文件下，所以出于安全需要把这个文件夹重新命名。因为我们的网页已经安装过了就不需要install文件了，把它删到，其他的像一些special等不需要的文件也删掉。把data目录下的关于数据库连接信息的文件common.inc.php改成只读模式，防止被篡改。最后是关于网站后台的登陆，一般默认用户名和密码都为admin，这个可以在数据库中进行修改，登陆主机的数据库，在dede_admin表中进行修改。用户名对应userid，密码对应pwd，数值用md5码加密过。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个网站我大概搭了一天多一点的时间吧，之前我也没接触过这些东西，算是零基础吧，正好有这个机会帮人建网站就尝试了一下。我总结一下我在搭建过程中遇到的问题吧，给后人乘凉了。<br>1.首先是选择操作系统，在购买时选择的操作系统是windows，之后ftp传文件都很顺利，直到进行安装时打开.php文件报404.3错误，我开始配置php文件映射，添加MIME类型，启用windows系统未开启的服务，在种种尝试中，发现还是报同样的错。刚开始以为我自己电脑的问题，后来换了几台电脑发现还是不行，所以我肯定问题不是出在这，在后来读阿里云的帮助文档时偶然发现，windows系统的主机不支持php文件。赶紧换了操作系统，重复导入步骤，这回在进行安装就不再报错了。<br>2.关于织梦模版文件，选择的时候要检查一下文件里的文件是否齐全，有的是不能用的，浪费时间，自己要注意区分。<br>3.关于连接自己的数据库，数据库主机项要填自己购买的数据库主机名，ip地址或者一个三级域名，不是默认的localhost，否则会一直连接失败</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前期准备&quot;&gt;&lt;a href=&quot;#前期准备&quot; class=&quot;headerlink&quot; title=&quot;前期准备&quot;&gt;&lt;/a&gt;前期准备&lt;/h2&gt;&lt;p&gt;一台云虚拟主机、域名、网站模版&lt;/p&gt;
&lt;h2 id=&quot;搭建步骤&quot;&gt;&lt;a href=&quot;#搭建步骤&quot; class=&quot;heade
      
    
    </summary>
    
    
      <category term="实践" scheme="http://yoursite.com/tags/%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP动态内存分配和回收</title>
    <link href="http://yoursite.com/2019/05/26/CSAPP%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6/"/>
    <id>http://yoursite.com/2019/05/26/CSAPP动态内存分配和回收/</id>
    <published>2019-05-26T09:01:18.000Z</published>
    <updated>2019-05-26T09:23:20.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><p>动态内存分配器维护着一个进程的虚拟内存区域，称为堆。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。<br>分配器分为两种类型:<br>显式分配器: 应用显式地释放任何已分配的块。<br>隐式分配器: 分配器检测一个已分配块何时不再被程序使用，那就释放这个块。隐式分配器也叫垃圾收集器，自动释放未使用的已分配块的过程称为垃圾收集.</p><h3 id="malloc和free"><a href="#malloc和free" class="headerlink" title="malloc和free"></a>malloc和free</h3><pre><code>#include &lt;stdlib.h&gt;void *malloc(size_t size);void free(void *ptr);</code></pre><p>malloc: 分配至少size字节的存储器块，这个块会为可能包含在这个块内的任何数据对象类型做对齐。在Unix系统上，malloc返回一个8字节(双字)边界对齐的块。</p><h3 id="分配器的数据结构"><a href="#分配器的数据结构" class="headerlink" title="分配器的数据结构"></a>分配器的数据结构</h3><p>分配器需要一些数据结构，允许它来区别块边界，以及区别已分配块和空闲块。<br>1.隐式空闲链表<br>一个简单的堆块的格式是，块由一个字的头部、有效载荷，以及可能的额外填充组成。头部编码了这个块的大小，以及这个块是已分配的还是空闲的。<br>我们可以将堆组织为一个连续的已分配块和空闲块的序列，这种结构称为隐式空闲链表。分配器可以通过遍历堆中所有的块，从而间接遍历整个空闲块的集合。<br>隐式空闲链表的优点是简单。显著缺点是任何操作的开销，例如放置分配的块，要求空闲链表的搜索与堆中已分配块和空闲块的总数呈线性关系。<br>放置已分配的块的放置策略:<br>首次适配<br>下一次适配<br>最佳适配<br>2.显式空闲链表<br>使用双向链表而不是隐式空闲链表，使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>垃圾收集器定期识别垃圾块(即程序不再需要的已分配块)，并相应的调用free，将这些块放回到空闲链表中.</p><h3 id="Mark-amp-Sweep-标记-amp-清除-算法"><a href="#Mark-amp-Sweep-标记-amp-清除-算法" class="headerlink" title="Mark&amp;Sweep(标记&amp;清除)算法"></a>Mark&amp;Sweep(标记&amp;清除)算法</h3><p>由标记(mark)阶段和清除(sweep)阶段组成，标记阶段标记出根节点的所有可达的已分配的后继，而后面的清除阶段释放每个未被标记的已分配块。在标记阶段的末尾，任何未标记的已分配块都被认定是不可达的，是垃圾，可以在清除阶段回收。</p><h2 id="C中常见的与内存相关的错误"><a href="#C中常见的与内存相关的错误" class="headerlink" title="C中常见的与内存相关的错误"></a>C中常见的与内存相关的错误</h2><p>存储器的错误总是令人沮丧的，特别是在运行了一段时间之后才显示出来，就特别特别的烦人了，列举一些常见的错误，仅供参考：</p><h3 id="间接引用坏指针"><a href="#间接引用坏指针" class="headerlink" title="间接引用坏指针"></a>间接引用坏指针</h3><p>将本来的地址引用写成了内容scanf(“%d”, &amp;val)写成scanf(“%d”, val)</p><h3 id="读未初始化的存储器："><a href="#读未初始化的存储器：" class="headerlink" title="读未初始化的存储器："></a>读未初始化的存储器：</h3><p>在堆中申请了一块空间：int *y = (int *)Malloc(n * sizeof(int));由于堆中的空间是未被初始化的，下面的使用就会出错：y[i] += A[i][j] * x[j];推荐使用calloc函数</p><h3 id="允许栈缓冲溢出："><a href="#允许栈缓冲溢出：" class="headerlink" title="允许栈缓冲溢出："></a>允许栈缓冲溢出：</h3><p>推荐使用fgets函数</p><h3 id="假设指针和它指向的对象是相同大小的"><a href="#假设指针和它指向的对象是相同大小的" class="headerlink" title="假设指针和它指向的对象是相同大小的"></a>假设指针和它指向的对象是相同大小的</h3><p>使用int **A = (int **)Malloc(n * sizeof(int));本来是想创建的一个int *的数组，但是sizeof上面用到的确是int</p><h3 id="错位"><a href="#错位" class="headerlink" title="错位"></a>错位</h3><p>申请了n个空间，却要访问n+1处位置</p><h3 id="引用指针而不是它指向的对象"><a href="#引用指针而不是它指向的对象" class="headerlink" title="引用指针而不是它指向的对象"></a>引用指针而不是它指向的对象</h3><p>*size–; /* This should be (*size)– */<br>其中，–和*有相同的优先级，由于这是右结合。所以先–再*，就出错了。</p><h3 id="误解指针运算"><a href="#误解指针运算" class="headerlink" title="误解指针运算"></a>误解指针运算</h3><p>p += sizeof(int); /* Should be p++ */<br>指针p++就会指向下一个位置，+= int的大小的话，就跳了几个数据了</p><h3 id="引用不存在的变量"><a href="#引用不存在的变量" class="headerlink" title="引用不存在的变量"></a>引用不存在的变量</h3><p>本地变量在栈中创建，函数结束以后就已经不存在了。</p><h3 id="引用已经释放了的块中的数据"><a href="#引用已经释放了的块中的数据" class="headerlink" title="引用已经释放了的块中的数据"></a>引用已经释放了的块中的数据</h3><p>在行10的时候已经将块释放了，在行14的时候又在使用.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;动态内存分配&quot;&gt;&lt;a href=&quot;#动态内存分配&quot; class=&quot;headerlink&quot; title=&quot;动态内存分配&quot;&gt;&lt;/a&gt;动态内存分配&lt;/h2&gt;&lt;p&gt;动态内存分配器维护着一个进程的虚拟内存区域，称为堆。对于每个进程，内核维护着一个变量brk，它指向堆的顶部。
      
    
    </summary>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP虚存的使用和管理</title>
    <link href="http://yoursite.com/2019/05/24/CSAPP%E8%99%9A%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/05/24/CSAPP虚存的使用和管理/</id>
    <published>2019-05-24T12:31:02.000Z</published>
    <updated>2019-05-24T13:14:35.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="物理寻址和虚拟寻址"><a href="#物理寻址和虚拟寻址" class="headerlink" title="物理寻址和虚拟寻址"></a>物理寻址和虚拟寻址</h2><p>使用虚拟寻址时，CPU通过生成一个虚拟地址来访问主存，这个虚拟地址在被送到存储器之前先转换成适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做地址翻译。地址翻译需要CPU硬件和操作系统之间的紧密合作。CPU芯片上叫做存储器管理单元的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容是由操作系统管理的。</p><h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p>一个地址空间的大小是由表示最大地址所需要的位数来描述的。一个包含N=2^n个地址的虚拟地址空间就叫做一个n位地址空间。现代操作系统典型的支持32位或者64为虚拟地址空间。一个系统还有一个物理地址空间，它与系统中物理存储器的M个字节相对应。</p><h2 id="虚拟内存的作用"><a href="#虚拟内存的作用" class="headerlink" title="虚拟内存的作用"></a>虚拟内存的作用</h2><p>使用虚拟内存有许多的好处，操作系统其实为每个进程提供了一个独立的页表，使用不同的页表也就创建了独立的虚拟地址空间。使用虚拟内存可以简化链接、简化加载、简化共享、简化存储器分配、简化保护。</p><h2 id="地址翻译"><a href="#地址翻译" class="headerlink" title="地址翻译"></a>地址翻译</h2><h3 id="命中的地址翻译过程"><a href="#命中的地址翻译过程" class="headerlink" title="命中的地址翻译过程"></a>命中的地址翻译过程</h3><p>1.处理器生成虚拟地址 VA，传给 MMU；<br>2.MMU 生成 PTE 地址，通过高速缓存或主存请求得到它；<br>3.高速缓存或主存返回PTE；<br>4.MMU 构造物理地址，并传送给高速缓存或主存；<br>5.高速缓存或主存返回请求的数据字给处理器。</p><h3 id="不命中的地址翻译过程"><a href="#不命中的地址翻译过程" class="headerlink" title="不命中的地址翻译过程"></a>不命中的地址翻译过程</h3><p>1.处理器生成虚拟地址 VA，传给 MMU；<br>2.MMU 生成 PTE 地址，通过高速缓存或主存请求得到它；<br>3.高速缓存或主存返回PTE；<br>4.PTE 有效位为 0，传递 CPU 的控制，让操作系统内核执行缺页异常处理程序<br>5.确定物理内存的牺牲页，如果该牺牲页已被修改则换出磁盘；<br>6.缺页处理程序页面调入新的页面，并更新内存中的 PTE。<br>7.返回到原来的进程，再次执行缺页指令，此时会命中，MMU 将返回请求的数据字给处理器。</p><h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>内存映射是指将磁盘上的一个文件与虚拟存储器中的一个区域关联起来的这个过程。</p><h3 id="共享对象"><a href="#共享对象" class="headerlink" title="共享对象"></a>共享对象</h3><p>一个对象被映射到虚拟存储器的一个区域，这个区域要么是共享对象，要么是私有对象。如果一个进程A将一个共享对象映射X到了它的虚拟存储器中，那么对于同时也映射了这个共享对象X的其他进程而言，进程A对共享对象X的任何读写操作都是可见的。对于一个映射到私有对象的区域做的改变，对于其他进程来说是不可见的，并且进程对这个区域所做的任何写操作都不会反映在磁盘上的对象中。<br>每个对象都有唯一的一个文件名，在进程1的虚拟存储器中已经完成了私有对象到存储器的映射，进程2如果要映射这个区域只需要将页表条目指向已经映射好的物理存储器位置就行了。如上图所示，进程1和2将一个私有对象映射到了物理存储器的一个区域并共享这个私有对象。这个对象会被标记为只读，当其中一个进程2确实需要写这个区域的时候，就会引发一个保护故障，内核会在物理存储器中创建这个私有对象的一个拷贝，称为写时拷贝，更新页面条目使得进程1指向这个新的条目。然后把老对象修改为可写权限。这样当保护故障程序返回的时候，CPU从新执行写的操作就不会出错了。</p><h3 id="fork函数如何创建独立的虚拟地址空间"><a href="#fork函数如何创建独立的虚拟地址空间" class="headerlink" title="fork函数如何创建独立的虚拟地址空间"></a>fork函数如何创建独立的虚拟地址空间</h3><p>一个进程调用fork函数的时候，内核为新进程创建各种数据结构，并分配PID。为了给新进程创建一个虚拟存储器，它创建的当前进程的mm_struct、区域结构和页表的一个拷贝，内核为两个进程的每个页表标记为只读，并将诶个区域标记为私有的写时拷贝。这样当fork函数返回的时候，新进程的虚拟存储器和当前进程的虚拟存储器刚好相同。任何一个进程进行写操作的时候，才会创建新的页面。</p><h3 id="execve函数实际上如何加载和执行程序"><a href="#execve函数实际上如何加载和执行程序" class="headerlink" title="execve函数实际上如何加载和执行程序"></a>execve函数实际上如何加载和执行程序</h3><p>1.删除已存在的用户区域；<br>2.映射私有区域<br>3.映射共享区域；<br>4.设置程序计数器。</p><h3 id="使用mmap函数创建新的存储器映射"><a href="#使用mmap函数创建新的存储器映射" class="headerlink" title="使用mmap函数创建新的存储器映射"></a>使用mmap函数创建新的存储器映射</h3><p>mmap函数要求内核创建一个新的虚拟内存区域，从地址start开始处创建，并将文件描述符fd指定的对象的一个连续的片映射到这个新的区域。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;物理寻址和虚拟寻址&quot;&gt;&lt;a href=&quot;#物理寻址和虚拟寻址&quot; class=&quot;headerlink&quot; title=&quot;物理寻址和虚拟寻址&quot;&gt;&lt;/a&gt;物理寻址和虚拟寻址&lt;/h2&gt;&lt;p&gt;使用虚拟寻址时，CPU通过生成一个虚拟地址来访问主存，这个虚拟地址在被送到存储器之前
      
    
    </summary>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Y86-64的流水线实现</title>
    <link href="http://yoursite.com/2019/05/22/CSAPP-Y86-64%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/05/22/CSAPP-Y86-64的流水线实现/</id>
    <published>2019-05-22T09:38:02.000Z</published>
    <updated>2019-05-22T11:34:21.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流水线的概述"><a href="#流水线的概述" class="headerlink" title="流水线的概述"></a>流水线的概述</h2><p>简单来说流水线这个概念出现在我们日常生活中，比如餐厅的服务线和自动汽车清洗线都是应用于这个原理。流水线化的一个重要特性就是提高了系统的吞吐量，不过它也会轻微地增加延迟。</p><h2 id="流水线的局限性"><a href="#流水线的局限性" class="headerlink" title="流水线的局限性"></a>流水线的局限性</h2><p>1、不一致的划分<br>之前的是一个理想的流水线化的系统，每个阶段需要的时间都相同。而实际系统通过各阶段的延迟一般是不同的。且运行时钟的速率是由最慢阶段的延迟限制的。<br>2、流水线过深，收益反而下降<br>例如，我们把计算分成6个阶段，每个阶段需要50ps。在每对阶段之间插入流水线寄存器就得到了一个六阶段流水线。这个系统的最小时钟周期为50+20=70ps，吞吐量为14.29GIPS。性能比3阶段流水提高了14.29/8.33=1.71倍。由于通过流水线寄存器的延迟，吞吐量并没有加倍。这个延迟成了流水线吞吐量的一个制约因素。为了提高时钟频率，现代处理器采用了很深的流水线。</p><h2 id="流水线冒险"><a href="#流水线冒险" class="headerlink" title="流水线冒险"></a>流水线冒险</h2><p>使用流水线技术，当相邻指令间存在相关时会导致出现问题。这些相关有：<br>1、数据相关：下一条指令会用到这一条指令计算出的结果<br>2、控制相关：一条指令要确定下一条指令的位置，例如在执行跳转、调用或返回指令时。<br>这些相关可能会导致流水线产生计算错误，称为冒险。</p><h3 id="用暂停来避免数据冒险"><a href="#用暂停来避免数据冒险" class="headerlink" title="用暂停来避免数据冒险"></a>用暂停来避免数据冒险</h3><p>暂停是避免冒险的一种常用技术。让一条指令停顿在译码阶段，直到产生它的源操作数的指令通过了写回阶段，这样我们的处理器就能避免数据冒险。<br>暂停技术就是让一组指令阻塞在它们所处的阶段，而允许其他指令继续通过流水线。</p><h3 id="用转发来避免数据冒险"><a href="#用转发来避免数据冒险" class="headerlink" title="用转发来避免数据冒险"></a>用转发来避免数据冒险</h3><p>在译码阶段从寄存器文件中读入源操作数，但是对这些源寄存器的写有可能要在写回阶段才能进行。与其暂停直到写完成，不如简单地将要写的值传到流水线寄存器E作为源操作数。<br>（即，我们不必等到irmovl $10, %edx和irmovl $3, %eax 完成对寄存器的写更新之后再继续addl，而是在addl译码阶段发现需要%edx、%eax值，译码逻辑不从寄存器文件中去读，而是用前面阶段未写入寄存器的值。）这种将结果直接从一个流水线阶段传到较早阶段的技术称为数据转发。在周期4中，译码阶段逻辑发现有在访存阶段中对寄存器%edx未进行的写，还发现在执行阶段中正在计算寄存器%eax的新值。它用这些值，而不是从寄存器文件中读出的值，作为valA和valB的值。</p><h3 id="加载-使用数据冒险"><a href="#加载-使用数据冒险" class="headerlink" title="加载/使用数据冒险"></a>加载/使用数据冒险</h3><p>有一类数据冒险不能单纯用转发来解决，因为存储器读(访存阶段)在流水线发生的比较晚。<br>我们可以将暂停和转发结合起来，避免加载/使用数据冒险。（既然是来不及发送给后面的指令，那就让后面的指令暂停几个周期，再发送）<br>当mrmovl指令通过执行阶段时，流水线控制逻辑发现译码阶段中的指令(addl)需要从存储器中读出的结果。它会将译码阶段中的addl指令暂停一个周期，导致执行阶段中插入一个气泡。 mrmovl指令从存储器中读出的值可以从访存阶段转发到译码阶段中的addl指令。<br>这种用暂停来处理加载/使用冒险的方法称为加载互锁。加载互锁和转发技术结合起来足以处理所有可能类型的数据冒险。</p><h3 id="避免控制冒险"><a href="#避免控制冒险" class="headerlink" title="避免控制冒险"></a>避免控制冒险</h3><p>在处理器无法根据处于取址阶段的当前指令来确定下一条指令的地址时，就会出现控制冒险，一般来说控制冒险只会出现在ret和跳转指令上。当出现特殊情况时，通过暂停和往流水线中插入气泡的技术可以动态调整流水线的流程。</p><h2 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h2><p>流水线化设计的目的就是每个时钟周期都发射一条新指令，要做到这一点，我们必须在取出当前指令之后，马上确定下一条指令的位置。<br>但如果取出的指令是条件分支指令，要到几个周期后，也就是指令通过执行阶段之后，我们才能知道是否要选择分支。类似的，如果取出的指令是ret，要到指令通过访存阶段，才能确定返回地址。<br>对条件转移来说，我们既可以预测选择了分支，那么新PC值应为valC，也可以预测没有选择分支，那么新PC值应为valP。<br>对ret指令，可能的返回值几乎是无限的，因为返回地址位于栈顶的字，其内容可以是任意的。在设计中，我们不会试图对返回地址做任何预测。只是简单地暂停处理新指令，直到ret指令通过写回阶段。<br>无论哪种情况，我们都必须以某种方式来处理预测错误的情况，因为此时已经取出并部分执行了错误的指令。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>异常可以由程序执行从内部产生，也可以由某个外部信号从外部产生。简单的三种内部异常：<br>1、halt指令<br>2、非法指令<br>3、访问非法地址<br>在简化的ISA模型中，当处理器遇到异常时，会停止，设置适当的状态码，且应该是到异常指令之前的所有指令都已经完成，而其后的指令都不应该对程序员可见的状态产生任何影响。在一个更完整的设计中，处理器会继续调用异常处理程序，这是操作系统的一部分。<br>一般地，通过在流水线结构中加入异常处理逻辑，我们会在每个流水线寄存器中包括一个状态码Stat。如果一条指令在其处理器中于某个阶段产生了一个异常，这个状态字段就被设置成指示异常的种类。<br>异常状态和该指令的其他信息一起沿着流水线传播，直到它到达写回阶段。在此，流水线控制逻辑发现了异常，并停止执行。<br>异常事件不会对流水线中的指令流有任何影响，除了会禁止流水线中后面的指令更新程序员的可见状态，直到异常指令到达最后的流水线阶段。<br>因为指令到达写回阶段的顺序与它们在非流水化的处理器中执行的顺序相同，所以我们可以保证第一条遇到异常的指令会第一个到达写回阶段，此时程序执行会停止，流水线寄存器中的状态码会被记录为程序状态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;流水线的概述&quot;&gt;&lt;a href=&quot;#流水线的概述&quot; class=&quot;headerlink&quot; title=&quot;流水线的概述&quot;&gt;&lt;/a&gt;流水线的概述&lt;/h2&gt;&lt;p&gt;简单来说流水线这个概念出现在我们日常生活中，比如餐厅的服务线和自动汽车清洗线都是应用于这个原理。流水线化的一
      
    
    </summary>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Y86-64顺序的实现</title>
    <link href="http://yoursite.com/2019/05/20/CSAPP-Y86-64%E9%A1%BA%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/05/20/CSAPP-Y86-64顺序的实现/</id>
    <published>2019-05-20T12:48:06.000Z</published>
    <updated>2019-05-22T11:07:16.858Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Y86-64的顺序实现"><a href="#Y86-64的顺序实现" class="headerlink" title="Y86-64的顺序实现"></a>Y86-64的顺序实现</h2><h3 id="跟踪irmovq指令的执行"><a href="#跟踪irmovq指令的执行" class="headerlink" title="跟踪irmovq指令的执行"></a>跟踪irmovq指令的执行</h3><p>一条指令的执行过程通常可以分为取指-&gt;译码-&gt;执行-&gt;访存-&gt;写回-&gt;更新PC，下面以irmovq指令为例，详细的解释这条指令的执行过程。</p><table><thead><tr><th style="text-align:left">阶段</th><th style="text-align:left">通用</th><th style="text-align:left">具体</th></tr></thead><tbody><tr><td style="text-align:left"></td><td style="text-align:left">irmovq V,rB</td><td style="text-align:left">irmovq $128,%rsp</td></tr><tr><td style="text-align:left">取指</td><td style="text-align:left">icode:ifun&lt;-M1[PC]<br>rA:rB&lt;-M1[PC+1]<br>valC&lt;-M8[PC+2]<br>valP&lt;-PC+10</td><td style="text-align:left">M1[0x016]=3:0<br>M1[0x015]=f:4<br>valC&lt;-M1[0x018]=128<br>valP&lt;-0x020</td></tr><tr><td style="text-align:left">译码</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">执行</td><td style="text-align:left">valE&lt;-0+valC</td><td style="text-align:left">valE&lt;-128</td></tr><tr><td style="text-align:left">访存</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">写回</td><td style="text-align:left">R[rB]&lt;-valE</td><td style="text-align:left">R[rB]&lt;-128</td></tr><tr><td style="text-align:left">更新PC</td><td style="text-align:left">PC&lt;-valP</td><td style="text-align:left">PC&lt;-0x20</td></tr></tbody></table><p>其余的还有其他指令，比如ret、popq、rmmovq，它们的执行过程其实也都是遵循通用规则的。</p><h3 id="SEQ的时序"><a href="#SEQ的时序" class="headerlink" title="SEQ的时序"></a>SEQ的时序</h3><p>要控制处理器中活动的时序，只需要寄存器和内存的时钟控制。通过时钟周期来控制元素的更新，通过组合逻辑来传播，每次时钟周期由低到高时，处理器开始执行一条新指令。处理器从来不需要为了完成一条指令的执行而去读该指令更新了的状态。</p><h3 id="SEQ阶段的实现"><a href="#SEQ阶段的实现" class="headerlink" title="SEQ阶段的实现"></a>SEQ阶段的实现</h3><p>一条指令在顺序的处理器中执行一般来说需要五个阶段，需要根据不同的指令取出其所需要的数据，可以使用HCL来描述这个过程。SEQ执行只有当上一个阶段执行完才会执行下一个阶段，这样就会导致运行的很慢，而且不能充分利用硬件单元，在接下来会学习流水线化的运行原理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Y86-64的顺序实现&quot;&gt;&lt;a href=&quot;#Y86-64的顺序实现&quot; class=&quot;headerlink&quot; title=&quot;Y86-64的顺序实现&quot;&gt;&lt;/a&gt;Y86-64的顺序实现&lt;/h2&gt;&lt;h3 id=&quot;跟踪irmovq指令的执行&quot;&gt;&lt;a href=&quot;#跟踪ir
      
    
    </summary>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP逻辑设计</title>
    <link href="http://yoursite.com/2019/05/18/CSAPP%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2019/05/18/CSAPP逻辑设计/</id>
    <published>2019-05-18T10:30:54.000Z</published>
    <updated>2019-05-22T11:36:13.706Z</updated>
    
    <content type="html"><![CDATA[<h2 id="逻辑设计与HCL"><a href="#逻辑设计与HCL" class="headerlink" title="逻辑设计与HCL"></a>逻辑设计与HCL</h2><p>这部分内容应该是之前上过的一门课-数字电路设计与分析的精简版了吧，主要是讲各种逻辑电路的设计。</p><h3 id="逻辑门"><a href="#逻辑门" class="headerlink" title="逻辑门"></a>逻辑门</h3><p>基本的逻辑门类型有：AND、OR、NOT<br>逻辑门是活动的，输入变化输出就会变化。</p><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p><strong>1.单个位</strong><br>eq = (a &amp;&amp; b) || (!a &amp;&amp; !b) 这个表达式的结果分析，只有a 和 b 都为 0 或者都为 1 的时候，输出才为1。<br>(a &amp;&amp; s) || (b &amp;&amp; !s) 我们分析如果s为1，则结果为a，否则结果为b。<br><strong>2.多个位</strong><br>eq=(A==B) 这里A和B都是int型的，表达式是在判断64位字A和B中的每一位是否相同。</p><h3 id="HCL表达式-和-C-语言逻辑表达式的区别"><a href="#HCL表达式-和-C-语言逻辑表达式的区别" class="headerlink" title="HCL表达式 和 C 语言逻辑表达式的区别"></a>HCL表达式 和 C 语言逻辑表达式的区别</h3><p>1.逻辑门是持续输出的，如果电路的输入变化了，在一定的延迟之后，输出也会相应的变化，而C表达式是在执行到的时候才会求值。<br>2.两者操作的值不同，逻辑门只对值 0 和值 1 进行操作，而C 逻辑表达式允许参数是任意整数，0表示false，其它任意值都表示true。<br>3.逻辑表达式存在短路，比如对于a &amp;&amp; b这个符号来说，C语言中的规定是如果前者为假，则后者不会再计算。而HCL当中没有这种说法。</p><h3 id="存储器和时钟"><a href="#存储器和时钟" class="headerlink" title="存储器和时钟"></a>存储器和时钟</h3><p>组合电路是一直持续输出的，因此它无法保持一个状态不变。也就是说组合电路从本质上来讲，不存储任何信息。他们只是简单的响应输入信号，产生等于输入的某个函数的输出。但我们的计算机是需要存储数据的，因此就需要能保存状态的存储设备。存储设备是由一个时钟控制，时钟是一个周期型号，它控制着存储设备什么时候更新设备里的值。<br>常用的存储设备一般有两种：<br>时钟寄存器：简称寄存器，存储单个位或字。时钟信号控制寄存器加载输入值。<br>随机访问存储器：简称存储器，存储多个字，用地址来选择该读或者该写哪个字。</p><h2 id="Y86-64的顺序实现"><a href="#Y86-64的顺序实现" class="headerlink" title="Y86-64的顺序实现"></a>Y86-64的顺序实现</h2><p>处理一条指令包含很多操作，将它们组织成某个特殊的阶段序列。分为以下几个阶段：<br>取指：取指阶段从存储器读取指令字节，地址为程序计数器（PC）的值<br>译码：译码阶段从寄存器文件读入最多两个操作数,得到val A 和 / 或 val B<br>执行：执行阶段，算术/逻辑单元要么执行指令明确的操作（根据ifun的值），计算存储器引用的有效地址，要么增加或减少栈指针。得到的值为valE<br>访存：访存阶段可将数据写入存储器或从存储器读出数据<br>写回：最多可写两个结果到寄存器文件<br>更新PC：将PC设置成下一指令的地址</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;逻辑设计与HCL&quot;&gt;&lt;a href=&quot;#逻辑设计与HCL&quot; class=&quot;headerlink&quot; title=&quot;逻辑设计与HCL&quot;&gt;&lt;/a&gt;逻辑设计与HCL&lt;/h2&gt;&lt;p&gt;这部分内容应该是之前上过的一门课-数字电路设计与分析的精简版了吧，主要是讲各种逻辑电路的设计
      
    
    </summary>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP浮点数操作</title>
    <link href="http://yoursite.com/2019/05/17/CSAPP%E6%B5%AE%E7%82%B9%E6%95%B0%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/05/17/CSAPP浮点数操作/</id>
    <published>2019-05-17T09:26:07.000Z</published>
    <updated>2019-05-22T11:37:34.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浮点代码"><a href="#浮点代码" class="headerlink" title="浮点代码"></a>浮点代码</h2><p>处理器的浮点体系结构包括多个方面，会影响对浮点数据操作的程序如何被映射到机器上，包括：<br>1） 如何存储和访问浮点数据。通常是通过某种寄存器方式来完成。<br>2） 对浮点数据操作的指令。<br>3） 想函数传递浮点数参数和从函数返回浮点数结构的规则。<br>4） 函数调用过程保持寄存器的规则——例如，一些寄存器被指定为调用者保存，而其他的被指定为被调用者保存。<br>AVX浮点体系结构允许数据存储在16个YMM寄存器中，它们的名字为%ymm0~%ymm15。每个YMM寄存器都是256位（32位）。</p><h3 id="浮点传送和转换操作"><a href="#浮点传送和转换操作" class="headerlink" title="浮点传送和转换操作"></a>浮点传送和转换操作</h3><p>浮点传送和转换操作指令汇总</p><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">源1</th><th style="text-align:center">源2</th><th style="text-align:center">目的</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">vmovss</td><td style="text-align:center">M32</td><td style="text-align:center">NULL</td><td style="text-align:center">X</td><td style="text-align:center">传送单精度数</td></tr><tr><td style="text-align:center">vmovss</td><td style="text-align:center">X</td><td style="text-align:center">NULL</td><td style="text-align:center">M32</td><td style="text-align:center">传送单精度数</td></tr><tr><td style="text-align:center">vmovsd</td><td style="text-align:center">M64</td><td style="text-align:center">NULL</td><td style="text-align:center">X</td><td style="text-align:center">传送双精度数</td></tr><tr><td style="text-align:center">vmovsd</td><td style="text-align:center">X</td><td style="text-align:center">NULL</td><td style="text-align:center">M64</td><td style="text-align:center">传送双精度数</td></tr><tr><td style="text-align:center">vmovaps</td><td style="text-align:center">X</td><td style="text-align:center">NULL</td><td style="text-align:center">X</td><td style="text-align:center">传送对齐的封装好的单精度数</td></tr><tr><td style="text-align:center">vmovapd</td><td style="text-align:center">X</td><td style="text-align:center">NULL</td><td style="text-align:center">X</td><td style="text-align:center">传送对齐的封装好的双精度数</td></tr><tr><td style="text-align:center">vcvttss2si</td><td style="text-align:center">X/M32</td><td style="text-align:center">NULL</td><td style="text-align:center">R32</td><td style="text-align:center">用截断的方法把单精度数转换成整数</td></tr><tr><td style="text-align:center">vcvttsd2si</td><td style="text-align:center">X/M64</td><td style="text-align:center">NULL</td><td style="text-align:center">R32</td><td style="text-align:center">用截断的方法把双精度数转换成整数</td></tr><tr><td style="text-align:center">vcvttss2siq</td><td style="text-align:center">X/M32</td><td style="text-align:center">NULL</td><td style="text-align:center">R64</td><td style="text-align:center">用截断的方法把单精度数转换成四字整数</td></tr><tr><td style="text-align:center">vcvttsd2siq</td><td style="text-align:center">X/M64</td><td style="text-align:center">NULL</td><td style="text-align:center">R64</td><td style="text-align:center">用截断的方法把双精度数转换成四字整数</td></tr><tr><td style="text-align:center">vcvtsi2ss</td><td style="text-align:center">M32/R32</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">把整数转换成单精度数</td></tr><tr><td style="text-align:center">vcvtsi2sd</td><td style="text-align:center">M32/R32</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">把整数转换成双精度数</td></tr><tr><td style="text-align:center">vcvtsi2ssq</td><td style="text-align:center">M64/R64</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">把四字整数转换成单精度数</td></tr><tr><td style="text-align:center">vcvtsi2sdq</td><td style="text-align:center">M64/R64</td><td style="text-align:center">X</td><td style="text-align:center">X</td><td style="text-align:center">把四字整数转换成双精度数</td></tr><tr><td style="text-align:center">vcvtps2pd</td><td style="text-align:center">X1</td><td style="text-align:center">NULL</td><td style="text-align:center">X2</td><td style="text-align:center">**把X1中两个低位单精度值扩展成X2中的两个双精度值</td></tr><tr><td style="text-align:center">vunpcklps</td><td style="text-align:center">X1</td><td style="text-align:center">X2</td><td style="text-align:center">X3</td><td style="text-align:center">交叉放置X1和X2的值存储到X3中</td></tr></tbody></table><h3 id="过程中的浮点代码"><a href="#过程中的浮点代码" class="headerlink" title="过程中的浮点代码"></a>过程中的浮点代码</h3><p>在x86-64中，XMM寄存器用来向函数传递浮点参数，以及从函数返回浮点值。<br>1） XMM寄存器%xmm0~%xmm7最多可以传递8个浮点参数（额外的可以通过栈传递）。<br>2） 函数使用寄存器xmm0来返回浮点值。<br>3） 所有的XMM寄存器都是调用者保存的。被调用者可以不用保存就覆盖这些寄存器中任一个。 </p><h3 id="浮点运算操作"><a href="#浮点运算操作" class="headerlink" title="浮点运算操作"></a>浮点运算操作</h3><p>浮点的运算符和整数的运算符大同小异，需要注意的是AVX浮点操作不能以立即数值作为操作数。</p><h2 id="Y86指令集体系结构"><a href="#Y86指令集体系结构" class="headerlink" title="Y86指令集体系结构"></a>Y86指令集体系结构</h2><h3 id="Y86指令"><a href="#Y86指令" class="headerlink" title="Y86指令"></a>Y86指令</h3><p>首先我们要知道的是Y86指令是不存在的，这是本书的作者受到 IA32指令，也就是“x86”的启发，所假想出来的一种处理器体系结构，与 “x86” 相比，Y86指令集的数据类型、指令和寻址方式都要少一些，字节级编码也比较简单。但是它仍然足够完整，能够写一些简单的处理证书的程序，而设计一个Y86处理器要求我们面对许多处理器设计者同样面临的问题。所以学习Y86处理器的设计是很有必要的。<br>定义一个指令集体系结构，会包括定义各种状态元素，指令集和它们的编码、一组编程规范和异常处理事件。</p><h3 id="指令编码"><a href="#指令编码" class="headerlink" title="指令编码"></a>指令编码</h3><p>Y86每条指令的第一个字节有唯一的代码和功能组合，给定这个字节，我们就可以决定所有其他附加字节的长度和含义。这个性质保证了处理器可以无二义性的执行目标程序代码。即使代码嵌入在程序的其它字节中，只要从序列的第一个字节开始处理，我们仍然可以很容易的确定指令序列。反过来，如果不知道一段代码序列的起始位置，我们就不能准确的确定怎样将序列划分为单独的指令。对于试图直接从目标代码字节序列中抽取出机器级程序的反汇编程序和其它一些工具来说，就带来了困难。</p><h3 id="关于RISC和CISC"><a href="#关于RISC和CISC" class="headerlink" title="关于RISC和CISC"></a>关于RISC和CISC</h3><p>两种不同的指令集，各有利弊，这个在之前的博客中也做过对比，想说明的一点是，人们应该考虑如何把两种指令集做结合，才能把处理器作用发挥的更好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;浮点代码&quot;&gt;&lt;a href=&quot;#浮点代码&quot; class=&quot;headerlink&quot; title=&quot;浮点代码&quot;&gt;&lt;/a&gt;浮点代码&lt;/h2&gt;&lt;p&gt;处理器的浮点体系结构包括多个方面，会影响对浮点数据操作的程序如何被映射到机器上，包括：&lt;br&gt;1） 如何存储和访问浮点数据。
      
    
    </summary>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP数据结构</title>
    <link href="http://yoursite.com/2019/05/15/CSAPP%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2019/05/15/CSAPP数据结构/</id>
    <published>2019-05-15T08:37:54.000Z</published>
    <updated>2019-05-22T11:38:47.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机系统学习"><a href="#计算机系统学习" class="headerlink" title="计算机系统学习"></a>计算机系统学习</h2><h3 id="数组分配和访问"><a href="#数组分配和访问" class="headerlink" title="数组分配和访问"></a>数组分配和访问</h3><h4 id="数组的基本原则"><a href="#数组的基本原则" class="headerlink" title="数组的基本原则"></a>数组的基本原则</h4><p>数组是某种基本数据类型数据的集合，对于数据类型 T 和整型常数 N，数组的声明如下：</p><pre><code>T  A[N]</code></pre><p>上面的 A 称为数组名称。它有两个效果：<br>1.它在存储器中分配一个 L*N 字节的连续区域，这里 L 是数据类型 T 的大小（单位为字节）<br>2.A作为指向数组开头的指针，如果分配的连续区域的起始地址为xa，那么这个指针的值就是xa</p><h4 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h4><p>C语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩。也就是说，如果 P 是一个执行类型 T 的数据的指针，P 的值为 xp,那么表达式P+i 的值为 xp+L*i，这里 L 是数据类型T的大小。</p><h4 id="数组嵌套"><a href="#数组嵌套" class="headerlink" title="数组嵌套"></a>数组嵌套</h4><p>也就是数组的数组，比如二维数组 int A[5][3]。这个时候上面所讲的数组的分配和引用也是成立的。&amp;A[2][0]=xa+24</p><h4 id="定长数组和变长数组"><a href="#定长数组和变长数组" class="headerlink" title="定长数组和变长数组"></a>定长数组和变长数组</h4><p>如果在编译时数组的长度确定，我们就称为定长数组，反之则称为变长数组。<br>比如int A[10]，就是一个定长数组，它的长度为10，它的长度在编译时已经确定了，因为长度是一个常量。之前的C编译器不允许在声明数组时，将长度定义为一个变量，而只能是常量，不过当前的C/C++编译器已经开始支持动态数组，但是C++的编译器依然不支持方法参数。另外，C语言还提供了类似malloc和calloc这样的函数动态的分配内存空间，我们可以将返回结果强转为想要的数组类型。</p><h3 id="异质的数据结构"><a href="#异质的数据结构" class="headerlink" title="异质的数据结构"></a>异质的数据结构</h3><p>异质结构是指不同数据类型的数组组合，比如C语言当中的结构（struct）与联合（union）。在理解数组的基础上，这两种数据结构都非常好理解。</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>考虑一个结构的声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">    char c;</span><br><span class="line">&#125; A;</span><br></pre></td></tr></table></figure></p><p>这是一个非常简单的结构体，总共有12个字节，为什么是12个字节呢？这是因为数据对齐的原因。为了提高数据读取的速度，一般情况下会将数据以2的指数倍对齐，具体是2、4、8还是16，得根据具体的硬件设施以及操作系统来决定。<br>这样做的好处是，处理器可以统一的一次性读取4（也可能是其它数值）个字节，而不再需要针对特殊的数据类型读取做特殊处理。在这个例子来说，也就是说在读取a、b、c时，都可以统一的读取4个字节。特殊的，这里0-3的位置用于存储a，4-7的位置用于存储b，8的位置用于存储c，而9-11则用于填充，其中都是空的。</p><h4 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h4><p>与结构体不同的是，联合会复用内存空间，以节省内存，考虑一个联合的声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">union &#123;</span><br><span class="line">    int a;</span><br><span class="line">    int b;</span><br><span class="line">    char c;</span><br><span class="line">&#125; B;</span><br></pre></td></tr></table></figure></p><p>这次总共会占4个字节，这是因为a、b、c会共用4个字节，这样做的目的是为了节省内存空间，显然它比结构体节省了8个字节的空间。它与结构体最大的区别就在于，对a、b、c赋值时，联合会覆盖掉之前的赋值，而结构体则不会，结构体可以同时保存a、b、c的值。</p><h3 id="在机器级程序中将控制与数据结合起来"><a href="#在机器级程序中将控制与数据结合起来" class="headerlink" title="在机器级程序中将控制与数据结合起来"></a>在机器级程序中将控制与数据结合起来</h3><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><p>指针以一种统一方式，对不同数据结构中的元素产生引用。 </p><h4 id="GDB调试器的使用"><a href="#GDB调试器的使用" class="headerlink" title="GDB调试器的使用"></a>GDB调试器的使用</h4><p>GDB调试器是一种非常实用的辅助工具，可以更好地帮助我们通过阅读代码来推断程序的行为。具体的命令可以参考书上的表格。</p><h4 id="内存越界引用和缓冲区溢出"><a href="#内存越界引用和缓冲区溢出" class="headerlink" title="内存越界引用和缓冲区溢出"></a>内存越界引用和缓冲区溢出</h4><p>在栈中分配某个字符数组来保存字符串，但是字符串的长度超出了为数组分配的空间，这样就会引起缓冲器溢出。<br>缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数。这是一种最常见的通过计算机网络攻击系统安全的方法。</p><h4 id="对抗缓冲区溢出攻击"><a href="#对抗缓冲区溢出攻击" class="headerlink" title="对抗缓冲区溢出攻击"></a>对抗缓冲区溢出攻击</h4><p><strong>1.栈随机化</strong><br>为了在系统中插入攻击代码，攻击者既要插入代码，也要插入指向这段代码的指针，这个指针也是攻击字符串的一部分。产生这个指针需要知道这个字符串放置的栈地址。<br>栈随机化的思想使得栈的位置在程序每次运行时都有变化。这类技术称为地址空间布局随机化（Address-Space Layout Randomization)，简称ASLR。<br>通常攻击者使用”空操作雪橇（nop sled）“，使程序”滑过“目标序列，即在实际攻击代码前插入一段很长的nop(读作“no op”，no operation的缩写）指令。<br><strong>2.栈破坏检测</strong><br>计算机的第二道防线是能够检测到何时栈已经被破坏。<br>GCC提供一种栈保护者机制，来检测缓冲区越界。其思想是在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的金丝雀（canary），也称为哨兵值（guard value），是在程序每次运行时随机产生的。<br><strong>3. 限制可执行代码区域</strong><br>最后一招是消除攻击者向系统插入可执行代码的能力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;计算机系统学习&quot;&gt;&lt;a href=&quot;#计算机系统学习&quot; class=&quot;headerlink&quot; title=&quot;计算机系统学习&quot;&gt;&lt;/a&gt;计算机系统学习&lt;/h2&gt;&lt;h3 id=&quot;数组分配和访问&quot;&gt;&lt;a href=&quot;#数组分配和访问&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP过程的实现</title>
    <link href="http://yoursite.com/2019/05/13/CSAPP%E8%BF%87%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/05/13/CSAPP过程的实现/</id>
    <published>2019-05-13T09:45:11.000Z</published>
    <updated>2019-05-22T11:39:48.266Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机系统学习"><a href="#计算机系统学习" class="headerlink" title="计算机系统学习"></a>计算机系统学习</h2><p>今天学习了过程的控制，过程是软件中的一种抽象，可以在程序中的某个地方调用某个过程来实现某种功能。</p><h3 id="栈帧的结构"><a href="#栈帧的结构" class="headerlink" title="栈帧的结构"></a>栈帧的结构</h3><p>栈帧在过程中必不可少，如果我们要想搞清楚过程的实现，就必须先知道栈帧的结构是如何构成的。栈帧其实可以认为是程序栈的一段，而程序栈又是存储器的一段，因此栈帧说到底还是存储器的一段。<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g2zu8mtlm2j30jn0dx3yq.jpg" alt><br>这幅图可以表示栈帧的结构，它由一系列栈帧构成，这些栈帧每一个都对应一个过程，而且每一个帧指针+4的位置都存储着函数的返回地址，每一个帧指针指向的存储器位置当中都备份着调用者的帧指针。</p><h3 id="过程的实现"><a href="#过程的实现" class="headerlink" title="过程的实现"></a>过程的实现</h3><p>总的来说，过程实现当中，参数传递以及局部变量内存的分配和释放都是通过栈帧来实现的，大部分情况下，我们认为过程调用当中做了以下几个操作。<br>1、备份原来的帧指针，调整当前的帧指针到栈指针的位置<br>2、建立起来的栈帧就是为被调用者准备的，当被调用者使用栈帧时，需要给临时变量分配预留内存<br>3、备份被调用者保存的寄存器当中的值，如果有值的话，备份的方式就是压入栈顶。<br>4、使用建立好的栈帧，比如读取和写入，一般使用mov，push以及pop指令等等。<br>5、恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了。因此在恢复时，大多数会使用pop指令，但也并非一定如此。<br>6、释放被调用者的栈帧，释放就意味着将栈指针加大，而具体的做法一般是直接将栈指针指向帧指针。<br>7、恢复调用者的栈帧，恢复其实就是调整栈帧两端，使得当前栈帧的区域又回到了原始的位置。<br>8、弹出返回地址，跳出当前过程，继续执行调用者的代码。此时会将栈顶的返回地址弹出到PC，然后程序将按照弹出的返回地址继续执行。这个过程一般使用ret指令完成。<br>过程的实现大概就是以上八个步骤组成的，不过这些步骤并不都是必须的，有的时候，开启编译器的优化会优化掉很多步骤。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>过程在平时的程序中扮演着很重要的角色，基本上一些功能稍微复杂一点的程序都需要用到过程。过程可以帮助隐藏掉一些很复杂的实现步骤，甚至有一些过程可以直接提供API接口，只需要连接上接口就可以实现该过程的功能，同时这也在开发过程中帮助开发人员省了不少力气。通过本节的学习，我基本了解在汇编语言中，在调用过程时寄存器和程序内存会发生的变化，同时这也更好的帮助我理解寄存器的内部结构情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;计算机系统学习&quot;&gt;&lt;a href=&quot;#计算机系统学习&quot; class=&quot;headerlink&quot; title=&quot;计算机系统学习&quot;&gt;&lt;/a&gt;计算机系统学习&lt;/h2&gt;&lt;p&gt;今天学习了过程的控制，过程是软件中的一种抽象，可以在程序中的某个地方调用某个过程来实现某种功能。&lt;/
      
    
    </summary>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP汇编指令2</title>
    <link href="http://yoursite.com/2019/05/12/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05-12/"/>
    <id>http://yoursite.com/2019/05/12/CSAPP学习笔记5-12/</id>
    <published>2019-05-12T08:45:56.000Z</published>
    <updated>2019-05-19T04:51:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机系统学习"><a href="#计算机系统学习" class="headerlink" title="计算机系统学习"></a>计算机系统学习</h2><h3 id="条件码寄存器"><a href="#条件码寄存器" class="headerlink" title="条件码寄存器"></a>条件码寄存器</h3><p>书中列出了四种常用的寄存器，它们的名字与作用分别如下所述。<br>CF：进位标志寄存器，它记录无符号操作的溢出，当溢出时会被设为1。<br>ZF：零标志寄存器，当计算结果为0时将会被设为1。<br>SF：符号标志寄存器，当计算结果为负数时会被设为1。<br>OF：溢出标志寄存器，当计算结果导致了补码溢出时，会被设为1。<br>从上面寄存器的简单说明可以看出，ZF和SF可以判断结果的符号，而CF和OF可以判断无符号和补码的溢出。而我们平时使用的高级程序语言，就仅仅靠这四个寄存器，就可以演化出千变万化的流程控制。<br>几乎所有的算术与逻辑指令都会改变条件码寄存器的值，不过改变的前提是触发了条件码寄存器的条件。比如对于subl %edx,%eax这个减法指令，假设%edx和%eax寄存器的值都为0x10，则两者相减的结果为0，此时ZF寄存器将会被自动设为1。对于其它的指令运算，都是类似的，会根据结果的不同而设置不同的条件码寄存器。</p><h3 id="访问条件码"><a href="#访问条件码" class="headerlink" title="访问条件码"></a>访问条件码</h3><p>对于普通寄存器来讲，使用的时候一般是直接读取它的值，而对于条件码寄存器来说，则不一定非要读取它的值才能使用。对于条件码寄存器来讲，有三种使用方式，都可以让它发挥作用。<br>1、可以根据条件码寄存器的某个组合，将一个字节设置为0或1，其实这个就相当于读值。<br>2、可以直接条件跳转到程序的某个其它的部分。<br>3、可以有条件的传送数据。<br>这里面第一种方式其实就是普通寄存器的用法，直接读取条件码寄存器的值，然后进行使用。对于第二和第三种来说，就不是这样了，它们不会显示的读取条件码寄存器的值，而是直接使用。<br>本节最难的地方，就在于如何将条件码寄存器的组合与条件联系起来。只要理解了这一点，那么条件码寄存器就算是基本掌握了。对于所有的组合都基于a-b这样的前提，也就是说条件码寄存器的值是经过了一个减运算设置后的值。例如，对于e-&gt;ZF这样的形式，代表的意思是字母e作为后缀时，则以ZF的值为1视为条件成立。</p><table><thead><tr><th style="text-align:center">组合</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">e-&gt;ZF</td><td style="text-align:center">相等</td></tr><tr><td style="text-align:center">ne-&gt;~ZF</td><td style="text-align:center">不相等</td></tr><tr><td style="text-align:center">s-&gt;SF</td><td style="text-align:center">负数</td></tr><tr><td style="text-align:center">ns-&gt;~SF</td><td style="text-align:center">非负数</td></tr><tr><td style="text-align:center">l-&gt;SF^OF</td><td style="text-align:center">有符号的小于</td></tr><tr><td style="text-align:center">le-&gt;(SF^OF)或ZF</td><td style="text-align:center">有符号的小于等于</td></tr><tr><td style="text-align:center">g-&gt;~(SF^OF)&amp;~ZF</td><td style="text-align:center">有符号的大于</td></tr><tr><td style="text-align:center">ge-&gt;~(SF^OF)</td><td style="text-align:center">有符号的大于等于</td></tr><tr><td style="text-align:center">b-&gt;CF</td><td style="text-align:center">无符号的小于</td></tr><tr><td style="text-align:center">be-&gt;CF或ZF</td><td style="text-align:center">无符号的小于等于</td></tr><tr><td style="text-align:center">a-&gt;~CF&amp;~ZF</td><td style="text-align:center">无符号的大于</td></tr><tr><td style="text-align:center">ae-&gt;~CF</td><td style="text-align:center">无符号的大于等于</td></tr></tbody></table><h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><p>这个指令是我们程序实现流程控制的关键指令，它可以直接将程序跳转到指定的位置，又或者根据条件码寄存器的组合进行条件跳转。总的来说，跳转指令的地址编码一般有两种，第一种是基于PC的，第二种则是绝对地址。基于PC（程序计数器）是指给出一个偏移量，这个偏移量基于当前下一条指令的地址，也就是PC当中的值，这是一种最常用的方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3: eb 03         jmp 8 &lt;loop+0x8&gt;</span><br><span class="line">5: 48 d1 f8      sar %rax</span><br><span class="line">8：</span><br><span class="line">b: 7f f8         jg 5 &lt;loop+0x5&gt;</span><br><span class="line">d: f3 c3         repz retq</span><br></pre></td></tr></table></figure></p><p>对于3处字节编码的第二个字节为03，把它加上0x5，就是下一条指令的地址。而对于b处字节编码的第二个字节为f8，补码转换为10进制-8，加上0xd，得到0x5.<br>跳转指令一个最大的应用就是可以实现条件分支，一种是通过条件控制来实现，简单理解是先判断再执行；另一种是通过条件传送来实现，先执行再判断。这两种实现方式各有利弊，要根据实际的应用来判断使用哪一个更好。</p><h3 id="循环指令"><a href="#循环指令" class="headerlink" title="循环指令"></a>循环指令</h3><p>循环指令一般有三种do-while、while和for。<br><strong>do-while</strong><br>这个循环结构是先执行循环体的内容，然后再进行判断条件，成立继续循环，不成立就跳出。在汇编中可以使用cmp+label来模拟这个过程。<br><strong>while</strong><br>这个循环结构是先判断条件是否成立，然后才进入循环体。在汇编中一种是执行一个无条件跳转到循环结尾处，以此来执行初始的测试。另一种是先进行判断，然后就是do-while的过程。<br><strong>for</strong><br>for循环结构其实完全可以沿用while循环的方法，只需要把for的各个条件匹配到while中即可。</p><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><p>我平时在程序中很少使用到switch分支语句，它适用于那种对变量进行很密集的判断，这个最好的应用大概就是分别指令集了吧。switch语句的实现很简单，可以用多重if-else来理解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    movl    8(%ebp), %eax//取a</span><br><span class="line">    cmpl    $10, %eax//比较a和10</span><br><span class="line">    je    .L10//如果a等于10，跳到.L10进行a=a+10的操作</span><br><span class="line">    cmpl    $20, %eax//比较a和20</span><br><span class="line">    je    .L11//如果a等于20，跳到.L11进行a=a+20的操作</span><br><span class="line">    jmp    .L14//如果a不等于10也不等于20，则跳到.L14进行a=a+30的操作</span><br><span class="line">.L10:</span><br><span class="line">    addl    $10, 8(%ebp)//a=a+10</span><br><span class="line">    jmp    .L12//break</span><br><span class="line">.L11:</span><br><span class="line">    addl    $20, 8(%ebp)//a=a+20</span><br><span class="line">    jmp    .L12//break</span><br><span class="line">.L14:</span><br><span class="line">    addl    $30, 8(%ebp)//a=a+30</span><br><span class="line">.L12:</span><br><span class="line">    movl    12(%ebp), %eax//取b</span><br><span class="line">    movl    8(%ebp), %edx//取a</span><br><span class="line">    leal    (%edx,%eax), %eax//计算a+b并作为返回值</span><br><span class="line">    /* switch语句实现 */</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;计算机系统学习&quot;&gt;&lt;a href=&quot;#计算机系统学习&quot; class=&quot;headerlink&quot; title=&quot;计算机系统学习&quot;&gt;&lt;/a&gt;计算机系统学习&lt;/h2&gt;&lt;h3 id=&quot;条件码寄存器&quot;&gt;&lt;a href=&quot;#条件码寄存器&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP汇编指令1</title>
    <link href="http://yoursite.com/2019/05/10/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05-9-5-10/"/>
    <id>http://yoursite.com/2019/05/10/CSAPP学习笔记5-9-5-10/</id>
    <published>2019-05-10T09:47:38.000Z</published>
    <updated>2019-05-19T04:50:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机系统学习"><a href="#计算机系统学习" class="headerlink" title="计算机系统学习"></a>计算机系统学习</h2><p>开始学习第三章程序的机器级表示，我竟然惊喜地发现这一章的内容正是我想学习但一直没找到汇总很好的学习资源。这两天主要在学习关于汇编指令的基础知识。</p><h3 id="为什么要学习汇编"><a href="#为什么要学习汇编" class="headerlink" title="为什么要学习汇编"></a>为什么要学习汇编</h3><p>有的人说，汇编语言的可读性和可移植性都很差，高级语言很容易理解、兼容性很好。为什么要学汇编语言而不是高级语言？<br>因为想要真正了解计算机系统，了解计算机是如何工作的，想要做一些漏洞分析，汇编语言都是必不可少的。</p><h3 id="生成汇编代码"><a href="#生成汇编代码" class="headerlink" title="生成汇编代码"></a>生成汇编代码</h3><p>一般生成汇编代码有两种途径，一种是从高级语言生成汇编代码，这时可以借助gcc编译器，比如在Linux环境下，使用命令</p><pre><code>&gt; gcc -Og -S xx.c</code></pre><p>就可以看到C语言编译器产生的汇编代码了；而另一种是对可执行程序反汇编生成汇编代码，在Linux上一般使用objdump工具，敲命令行</p><pre><code>&gt; objdump -d xx.o</code></pre><h3 id="汇编指令概述"><a href="#汇编指令概述" class="headerlink" title="汇编指令概述"></a>汇编指令概述</h3><p><strong>汇编代码格式</strong><br>汇编代码格式有两种，分别是是ATT和Intel格式，关于这两种汇编格式，在我之前的博客中做过总结。本书中用到的都是ATT格式的汇编代码。<br><strong>数据格式</strong><br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g2we1z27mxj30hb073t9b.jpg" alt><br><strong>寄存器</strong><br>寄存器是CPU当中非常重要的对象，一般情况下，很多临时变量都会存储在这里.下面是一张书中的寄存器图示，它基于IA32架构给出。<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g2we40o0vzj30do0aodge.jpg" alt><br><strong>操作数指令符</strong><br>不同指令符的表示方式一共有三种，一种是$符号后跟一个标准C表示的整数，比如$100，$0x11等等。第二种则是寄存器，当它作为一个操作数的时候，则是取的寄存器当中的数值。另外，对于寄存器来说，也可以选择性的操作4个、2个、1个字节，而并不一定非要操作4个字节。最后一种，则是我们相对来说最熟悉的，就是存储器或者说内存。当它作为一个操作数的时候，会去计算存储器地址的数值，然后去这个地址取相应的数值。</p><h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p>数据传送指令的目的是为了将一个数据从一个位置复制到另外一个位置。既然如此，那么数据传送指令就会包含一个源操作数和一个目的操作数，指令会将原操作数的值复制到目的操作数并覆盖。<br>数据传送指令一共可分为五种，分别是mov、movs、movz、push以及pop。这几种指令之前也分别做过总结，通过学习本节更系统地了解这些指令，算是复习了一遍吧。</p><h3 id="算术与逻辑运算操作指令"><a href="#算术与逻辑运算操作指令" class="headerlink" title="算术与逻辑运算操作指令"></a>算术与逻辑运算操作指令</h3><p>算术与逻辑运算包括很多种，比如最常见的加减乘除、与或非、左移右移等等。基本的加减乘除，位操作都比较基础了，这里就不再多说。通过本书我还学到了一个很精妙的指令，就是取地址运算符leaq。<br>leaq指令是非常神奇的一个指令，它可以取一个存储器操作数的地址，并且将其赋给目的操作数。如果用C语言当中来对应的话，它就相当于&amp;运算。<br>比如对于leaq 4(%rdx,%rdx,4),%rax这条指令来讲，我们假设%rdx寄存器的值为x的话，那么这条指令的作用就是将 4 + x + 4x = 5x + 4赋给%rax寄存器。它和mov指令的区别就在于，假设是movq 4(%rdx,%rdx,4),%rax这个指令，它的作用是将内存地址为5x+4的内存区域的值赋给%rax寄存器，而leaq指令只是将5x+4这个地址赋给目的操作数%rax而已，它并不对存储器进行引用的值的计算。<br>leaq指令能执行加法和有限形式的乘法，在编译一些比较复杂的算术表达式，使用leaq指令就会变得很简单，能有效减少程序的大小，提高代码执行效率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;计算机系统学习&quot;&gt;&lt;a href=&quot;#计算机系统学习&quot; class=&quot;headerlink&quot; title=&quot;计算机系统学习&quot;&gt;&lt;/a&gt;计算机系统学习&lt;/h2&gt;&lt;p&gt;开始学习第三章程序的机器级表示，我竟然惊喜地发现这一章的内容正是我想学习但一直没找到汇总很好的学习资
      
    
    </summary>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP浮点数</title>
    <link href="http://yoursite.com/2019/05/08/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05-8/"/>
    <id>http://yoursite.com/2019/05/08/CSAPP学习笔记5-8/</id>
    <published>2019-05-08T11:29:20.000Z</published>
    <updated>2019-05-19T04:51:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机系统学习"><a href="#计算机系统学习" class="headerlink" title="计算机系统学习"></a>计算机系统学习</h2><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>为了让数值的表示更加精确，或者表示一些整数无法达到的数字，比如一些接近于0的数字，或者一些非常大的数值就需要用到浮点数了。浮点数对于计算机的意义，可以说是相当之大。<br>IEEE标准采用类似于科学计数法的方式表示浮点小数，即我们将每一个浮点数表示为 V = (-1)^s*M*2^E 。<br>这其中s为符号位，为0时为正，为1时为负。M为尾数，是一个二进制小数，它的范围是0至1-ε，或者1至2-ε（。E为阶码，是一个二进制整数，可正可负，为了给尾数加权。<br>浮点格式分为两种，一种是单精度，一种是双精度。单双精度分别对应于编程语言当中的float和double类型。其中float是单精度的，采用32位二进制表示，其中1位符号位，8位阶码以及23位尾数。double是双精度的，采用64位二进制表示，其中1位符号位，11位阶码以及52位尾数。<br>针对阶码E的值，浮点数的值可以分为三种不同的情况，分别是规格化的，非规格化的以及特殊值。我记得之前在上计算机组成原理课的时候，老师比较年轻生怕我们听不懂，就总让我提问，我曾经就提了一个关于规格化的问题，但具体是什么忘了，人上了岁数总容易忘事。所谓规格化就是E不为0也不为全1，当E为0时就是非规格化，特殊值就是无穷大或者不能表示的数。<br>计算浮点格式的数的值，过程比较简单，按照书上的过程直接算就行，这里就不再写了。</p><h3 id="浮点数的舍入"><a href="#浮点数的舍入" class="headerlink" title="浮点数的舍入"></a>浮点数的舍入</h3><p>针对浮点数来说，我们的舍入方式有四种方式，分别是向偶数舍入、向零舍入、向上舍入以及向下舍入。通常情况下我们采取的舍入规则是在原来的值是舍入值的中间值时，采取向偶数舍入，在二进制中，偶数我们认为是末尾为0的数。而倘若不是这种情况的话，则一般会有选择性的使用向上和向下舍入，但总是会向最接近的值舍入。其实这正是IEEE采取的默认的舍入方式，这种方式在进行数据统计的时候，更加科学一些，50%的概率嘛。</p><h3 id="浮点数的运算"><a href="#浮点数的运算" class="headerlink" title="浮点数的运算"></a>浮点数的运算</h3><p>浮点数的运算比较特殊，不支持加法的结合律，(3.14+1e10)-1e10!=3.14+(1e10-1e10)；也不支持乘法的结合律和分配律,(1e20*1e20)*1e-20!=1e20*(1e20*1e-20),1e20*(1e20-1e20)!=1e20*1e20 +1e20*1e20</p><h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><p>通过本章的学习，了解计算机中对数的表示，不同类型的数有不同的性质。在今后写程序中，也会注意不同类型的数在转换时，运算时的表达形式，尽量避免由于数的某些错误而导致整个程序意想不到的结果。</p><h2 id="今日总结"><a href="#今日总结" class="headerlink" title="今日总结"></a>今日总结</h2><p>今天在另一台电脑上重新搭静态博客，真是一把辛酸泪，碰到的问题很多，比如图床的问题，还有gitalk的一些问题。等我解决好这些问题，再进行个整理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;计算机系统学习&quot;&gt;&lt;a href=&quot;#计算机系统学习&quot; class=&quot;headerlink&quot; title=&quot;计算机系统学习&quot;&gt;&lt;/a&gt;计算机系统学习&lt;/h2&gt;&lt;h3 id=&quot;浮点数&quot;&gt;&lt;a href=&quot;#浮点数&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP整数的运算</title>
    <link href="http://yoursite.com/2019/05/07/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05-7/"/>
    <id>http://yoursite.com/2019/05/07/CSAPP学习笔记5-7/</id>
    <published>2019-05-07T07:41:26.000Z</published>
    <updated>2019-05-19T04:54:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机系统学习"><a href="#计算机系统学习" class="headerlink" title="计算机系统学习"></a>计算机系统学习</h2><h3 id="整数的运算"><a href="#整数的运算" class="headerlink" title="整数的运算"></a>整数的运算</h3><p>平时的编程过程中，当进行整数运算时，经常会遇到一些奇怪的结果，比如两个正数加出负数，两个负数可以加出一个正数，这些都是由于数值表示的有限性导致的。<br><strong>无符号的加法</strong><br>二进制整数的加法与我们平时的十进制算法有一个最大的区别，那就是我们在计算机当中进行计算时，结果的位数都是有限制的。因此在我们计算过后，可能需要对结果进行截断操作。如果结果用超出规定的位才能表示，就算是溢出。所以来说无符号的加法只要不溢出就可以按照正常的加法来算，但如果出现溢出就需要减2^w。<br><strong>补码的加法</strong><br>对于补码加法就是可以先按照无符号加法进行运算，然后再进行无符号和有符号的转换。<br>与无符号加法不同的是，补码的加法会出现三种结果，一种是正常的结果，一种是正溢出，一种是负溢出。对于当正溢出的时候，我们的结果与无符号数类似，相加后的结果减去2^w。而当负溢出的时候，则刚好相反，相加后的结果加上2^w。<br><strong>补码的非</strong><br>先明白一个概念，对于任意一个w位的补码数t来说，它都有唯一的逆元t^-1，使得t + t^-1 = 0。<br>一个w位的补码数的范围在-2^(w-1）到2^(w-1)之间，直观的可以看出，对于不等于-2^(w-1)的补码数x来说，它的逆元就是-x。而对于-2^(w-1)来说，它的二进制位表示为1后面跟着w-1个0，我们需要找到一个数与其相加之后结果为0。这种时候我们需要考虑的是，如果是-x，也就是2^(w-1)，则它的位表示需要w+1位，是不存在的。因此我们需要考虑溢出的情况,负溢出的时候需要加上2^w，因此-2w-1的逆元就是-2^w + 2^(w-1) = -2^(w-1)，也就是它本身。<br><strong>无符号乘法</strong><br>无符号的乘法与加法类似，它的运算方式是比较简单的，只是也可能产生溢出。对于两个w位的无符号数来说，它们的乘积范围在0到(2^w-1)^2之间，因此可能需要2w位二进制才能表示。因此由于位数的限制，假设两个w位的无符号数的真实乘积为result，根据截断的规则，则实际得到的乘积为 result mod 2^w。<br><strong>补码乘法</strong><br>与加法运算类似，补码乘法也是建立在无符号的基础之上的，因此我们可以很容易的得到，对于两个w位的补码数来说，假设它们的真实乘积为result，则实际得到的乘积为 U2Tw(result mod 2^w)。<br><strong>乘以常数</strong><br>对于一个w位的二进制数来说，它与2^k的乘积，等同于这个二进制数左移k位，在低位补k个0。<br><strong>除以2的幂</strong><br>1.除以2的幂的无符号除法：对于一个w位的二进制数来说，它除以2^k，等同于这个二进制数右移k位，在高位补k个0。<br>2.除以2的幂的补码除法：对于一个w位的非负数的二进制数来说，它除以2^k，等同于这个二进制数右移k位，在高位补k个1；而对于一个w位的负数的二进制数来说，它除以2^k，要先加上2^k-1,然后再右移k位，在高位补k个1。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>计算机执行整数运算实际上是一种模运算形式，由于数字长度的限制，就会出现溢出的现象，这样就会导致程序运行错误，也会出现许多漏洞，比如在分配地址空间时，发生了正溢出，得到的结果比我们预想的小得多，这样就会导致分配的地址空间变小，而对这些空间进行某些操作时，会破坏超出这些地址空间的数据。</p><h2 id="地址传送指令"><a href="#地址传送指令" class="headerlink" title="地址传送指令"></a>地址传送指令</h2><table><thead><tr><th style="text-align:center">指令格式</th><th style="text-align:center">名称</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">lea r16,mem</td><td style="text-align:center">有效地址传送指令</td><td style="text-align:center">r16&lt;-mem的有效地址</td></tr><tr><td style="text-align:center">lds r16,mem</td><td style="text-align:center">指针传送指令</td><td style="text-align:center">r16&lt;-mem，DS&lt;-mem+2</td></tr><tr><td style="text-align:center">les r16,mem</td><td style="text-align:center">指针传送指令</td><td style="text-align:center">r16&lt;-mem,ES&lt;-mem+2</td></tr></tbody></table><p>LEA指令将存储器操作数mem的4位16进制偏移地址送到指定的寄存器。这里，源操作数必须是存储器操作数，目标操作数必须是16位通用寄存器。对于LEA指令来说变量其后面的有无[]皆可，都表示取变量地址，相当于指针；寄存器无[]表示取地址，有[]表示取值。<br>lds和les的操作过程差不多，r16是一个16位寄存器,mem是一个存储器操作数,为双字项,高16位送入DS/ES,低16位送入r16.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;计算机系统学习&quot;&gt;&lt;a href=&quot;#计算机系统学习&quot; class=&quot;headerlink&quot; title=&quot;计算机系统学习&quot;&gt;&lt;/a&gt;计算机系统学习&lt;/h2&gt;&lt;h3 id=&quot;整数的运算&quot;&gt;&lt;a href=&quot;#整数的运算&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP整数的拓展与截断</title>
    <link href="http://yoursite.com/2019/05/06/CSAPP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05-6/"/>
    <id>http://yoursite.com/2019/05/06/CSAPP学习笔记5-6/</id>
    <published>2019-05-06T08:56:38.000Z</published>
    <updated>2019-05-19T04:53:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机系统学习"><a href="#计算机系统学习" class="headerlink" title="计算机系统学习"></a>计算机系统学习</h2><p>今天学习了对二进制整数的位进行拓展和截断表示。</p><h3 id="拓展数字"><a href="#拓展数字" class="headerlink" title="拓展数字"></a>拓展数字</h3><p style="text-indent:2em">假如我们将一个短整型的变量转换为整型变量，由两个字节扩充为四个字节，这时就涉及到了位的扩展。</p><br><p style="text-indent:2em">在进行位的扩展时，最容易想到的就是在高位全部补0，也就是将原来的二进制序列前面加入若干个0，也称为零扩展。还有一种方式比较特别，是符号扩展，也就是针对有符号数的方式，它是直接扩展符号位，也就是将二进制序列的前面加入若干个最高位。</p><br><p style="text-indent:2em">对于零扩展来说，很明显扩展之后的值与原来的值是相等的，而对于符号扩展来说，则是一样，只不过没有零扩展来的直接。我们在计算补码时有一个比较简单的办法，就是符号位若为0，则与无符号是类似的。若符号位为1，也就是负数时，可以将其余位取反最终再加1即可。因此当我们对一个有符号的负数进行符号扩展时，前面加入若干个1，在取反之后都为0，因此依旧会保持原有的数值。</p><br><p style="text-indent:2em">总之，在对位进行扩展时，是不会改变原有数值的。</p><br><p style="text-indent:2em">在书中对于负数的符号扩展还给出了这一过程的证明，这个证明使用了数学归纳法，具体过程如下。</p><br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g2rpns18k4j30gh08iglv.jpg" alt><br><p style="text-indent:2em">2的幂函数有一个特殊的属性，就是2^w-2^(w-1)=2^(w-1).因此加上一个权值为-2^w的位，和一个将权值为-2^(w-1)的位转为权值为2^(w-1)的位，这两项综合起来得到的结果是一样的。</p><h3 id="截断数字"><a href="#截断数字" class="headerlink" title="截断数字"></a>截断数字</h3><p></p><p style="text-indent:2em">截断与扩展相反，它是将一个多位二进制序列截断至较少的位数，也就是与扩展是相反的过程。</p><br>观察书中给的例子，我们可以发现截断可能会导致数据的失真。对于无符号编码来说，截断后就是剩余位数的无符号编码数值。在书中给出了这一简单过程的证明，它主要是想表明截断前与截断后的数值的关系是取余数所得到的。而对于有符号数来说，就是在截断无符号数的基础上加上一步，做一个无符号数转补码的操作。总的来说，无符号数的截断结果是<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g2rpzcjdebj30gi014jra.jpg" alt><br>而补码数字的截断结果是<br><img src="https://tva1.sinaimg.cn/large/007rAy9hgy1g2rq05yaqtj30gs01eq2v.jpg" alt><br>我在做习题2.24时卡了好久，自己做的结果和答案就是对不上，后来才发现题目要求将4位截断位3位，我一直以为是2位，做了半天好心酸。比如对于-1来说，二进制补码表示为1111，首先按截断的位数取余得到无符号数111，再将无符号数转为补码，按照昨天的公式得到7-8=-1.<p></p><h3 id="关于有无符号数转换的思考"><a href="#关于有无符号数转换的思考" class="headerlink" title="关于有无符号数转换的思考"></a>关于有无符号数转换的思考</h3><p>从上面的分析不难看出，具有有符号和无符号数的语言，在相互转换时可能会因此引起一些不必要的麻烦。而且无符号数除了能表示的最大值更大以外，似乎并没有太大的好处，因此有很多语言是不支持无符号数的。在Java语言中，就只有有符号数，这样省去了很多不必要的麻烦。<br>有符号数和无符号数在进行强制转换时可能会引起程序的错误，而当这种转换是隐式的时候，错误很难被发现，因而程序会得出莫名其妙的结果。很多函数也因为这种强制转换而存在漏洞，被有心人利用，比如getpeername函数，如果对一个补码的最小值按照无符号数来读，这样就会读出一个很大的数值，如果这个值代表一个地址，那么就可能会产生越界或者读到一些不被授权的信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;计算机系统学习&quot;&gt;&lt;a href=&quot;#计算机系统学习&quot; class=&quot;headerlink&quot; title=&quot;计算机系统学习&quot;&gt;&lt;/a&gt;计算机系统学习&lt;/h2&gt;&lt;p&gt;今天学习了对二进制整数的位进行拓展和截断表示。&lt;/p&gt;
&lt;h3 id=&quot;拓展数字&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
      <category term="深入理解计算机系统" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
